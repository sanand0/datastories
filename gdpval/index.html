<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Impact on Sectors & Occupations - GDPVal Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background-color: white;
            color: #333;
            line-height: 1.6;
            padding: 0;
            margin: 0;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: white;
            padding: 40px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 24px;
            }

            .subtitle {
                font-size: 16px;
            }

            .description {
                font-size: 14px;
            }
        }

        h1 {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 10px;
            line-height: 1.2;
            color: #000;
        }

        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }

        .description {
            font-size: 16px;
            margin-bottom: 30px;
            color: #333;
        }

        #treemap {
            width: 100%;
            height: auto;
            margin: 30px 0;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            line-height: 1.6;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            max-width: 350px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip strong {
            font-weight: 600;
        }

        /* Sector labels */
        .sector-label {
            font-size: 16px;
            font-weight: 700;
            fill: #000;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Occupation labels */
        .occupation-label {
            pointer-events: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .occupation-name {
            font-size: 12px;
            font-weight: 700;
            fill: #000;
        }

        .occupation-value {
            font-size: 11px;
            fill: #333;
        }

        /* Treemap cells */
        .cell {
            stroke: white;
            stroke-width: 2px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .cell:hover {
            opacity: 0.8;
            stroke: #333;
            stroke-width: 3px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            overflow: auto;
        }

        .modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            margin: auto;
            padding: 0;
            border-radius: 8px;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .modal-header {
            padding: 24px 30px;
            border-bottom: 2px solid #e0e0e0;
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            border-radius: 8px 8px 0 0;
        }

        .modal-header h2 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #000;
        }

        .modal-header .meta {
            font-size: 14px;
            color: #666;
            margin-bottom: 4px;
        }

        .close {
            position: absolute;
            right: 24px;
            top: 24px;
            font-size: 32px;
            font-weight: 300;
            color: #999;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .prompt-item {
            margin-bottom: 24px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }

        .prompt-header {
            background: #f5f5f5;
            padding: 16px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 15px;
            user-select: none;
        }

        .prompt-header:hover {
            background: #ebebeb;
        }

        .prompt-toggle {
            font-size: 20px;
            transition: transform 0.2s;
        }

        .prompt-toggle.open {
            transform: rotate(180deg);
        }

        .prompt-content {
            padding: 20px;
            display: none;
            background: white;
            border-top: 1px solid #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 14px;
            line-height: 1.7;
            color: #333;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }

        .prompt-content.visible {
            display: block;
        }

        .legend {
            margin: 30px 0;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 6px;
        }

        .legend-title {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-scale {
            display: flex;
            height: 30px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
        }

        .source {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 13px;
            color: #666;
            font-style: italic;
        }

        .source a {
            color: #326891;
            text-decoration: none;
        }

        .source a:hover {
            text-decoration: underline;
        }

        .loading {
            text-align: center;
            padding: 15px;
            font-size: 18px;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>The AI Impact Across U.S. Sectors and Occupations</h1>
        <div class="subtitle">An analysis of AI task augmentation potential based on OpenAI's GDPVal research</div>
        <div class="description">
            This visualization shows which sectors and occupations have the highest potential for AI-assisted task completion.
            The size of each rectangle represents the total compensation in that occupation, while the color indicates
            the maximum AI model win rate (the percentage of tasks where AI assistance was deemed valuable).
            Hover over any occupation to see details, or click to explore the specific tasks evaluated.
        </div>

        <div class="legend">
            <div class="legend-title">AI Task Augmentation Potential</div>
            <div class="legend-scale" id="legend-scale"></div>
            <div class="legend-labels">
                <span>0% (Low potential)</span>
                <span>50%</span>
                <span>100% (High potential)</span>
            </div>
        </div>

        <div id="treemap" class="loading">Loading data...</div>

        <div class="source">
            Source: <a href="https://openai.com/index/gdpval/" target="_blank">OpenAI GDPVal Paper</a> -
            Analysis of AI task augmentation potential across sectors and occupations
        </div>
    </div>

    <div class="tooltip"></div>

    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close">&times;</span>
                <h2 id="modal-title">Occupation</h2>
                <div class="meta" id="modal-sector"></div>
                <div class="meta" id="modal-stats"></div>
            </div>
            <div class="modal-body" id="modal-body">
            </div>
        </div>
    </div>

    <script>
        // Load CSV data
        Promise.all([
            d3.csv('compensation.csv'),
            d3.csv('win.csv'),
            d3.csv('prompts.csv')
        ]).then(([compensationData, winData, promptsData]) => {
            // Process data
            const occupations = new Map();

            // Add compensation data
            compensationData.forEach(d => {
                const key = `${d.Sector}|${d.Occupation}`;
                occupations.set(key, {
                    sector: d.Sector,
                    occupation: d.Occupation,
                    compensation: +d.Compensation,
                    models: []
                });
            });

            // Add win rate data
            winData.forEach(d => {
                const key = `${d.Sector}|${d.Occupation}`;
                if (occupations.has(key)) {
                    const occ = occupations.get(key);
                    occ.models.push({
                        model: d.Model,
                        win: +d.Win
                    });
                }
            });

            // Calculate max win rate for each occupation
            occupations.forEach(occ => {
                if (occ.models.length > 0) {
                    const maxModel = occ.models.reduce((max, curr) =>
                        curr.win > max.win ? curr : max
                    );
                    occ.maxWin = maxModel.win;
                    occ.maxModel = maxModel.model;
                } else {
                    occ.maxWin = 0;
                    occ.maxModel = 'N/A';
                }
            });

            // Add prompts - store all prompts per occupation
            const promptsMap = new Map();
            promptsData.forEach(d => {
                const key = `${d.Sector}|${d.Occupation}`;
                if (!promptsMap.has(key)) {
                    promptsMap.set(key, []);
                }
                promptsMap.get(key).push(d.Prompt);
            });

            // Create hierarchy
            const sectorGroups = d3.group(Array.from(occupations.values()), d => d.sector);
            const hierarchyData = {
                name: 'root',
                children: Array.from(sectorGroups, ([sector, occs]) => ({
                    name: sector,
                    children: occs.map(occ => ({
                        name: occ.occupation,
                        value: occ.compensation,
                        maxWin: occ.maxWin,
                        maxModel: occ.maxModel,
                        sector: occ.sector,
                        models: occ.models,
                        prompts: promptsMap.get(`${occ.sector}|${occ.occupation}`) || []
                    }))
                }))
            };

            // Create treemap
            const container = d3.select('#treemap');
            container.html(''); // Clear loading message

            function getContainerWidth() {
                return container.node().getBoundingClientRect().width;
            }

            let width = getContainerWidth();
            let height = width / 2; // 2:1 aspect ratio

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', [0, 0, width, height])
                .attr('style', 'max-width: 100%; height: auto;');

            // Color scale: diverging from red (0) to yellow (50) to green (100)
            const colorScale = d3.scaleLinear()
                .domain([0, 50, 100])
                .range(['#d73027', '#fee08b', '#1a9850'])
                .interpolate(d3.interpolateHcl);

            // Create treemap layout
            const treemap = d3.treemap()
                .size([width, height])
                .paddingOuter(3)
                .paddingTop(22)
                .paddingInner(2)
                .round(true);

            const root = d3.hierarchy(hierarchyData)
                .sum(d => d.value)
                .sort((a, b) => b.value - a.value);

            treemap(root);

            // Draw cells
            const cell = svg.selectAll('g')
                .data(root.leaves())
                .join('g')
                .attr('transform', d => `translate(${d.x0},${d.y0})`);

            const tooltip = d3.select('.tooltip');

            cell.append('rect')
                .attr('class', 'cell')
                .attr('width', d => d.x1 - d.x0)
                .attr('height', d => d.y1 - d.y0)
                .attr('fill', d => colorScale(d.data.maxWin))
                .on('mouseover', function(event, d) {
                    tooltip.classed('visible', true);
                    const modelName = d.data.maxModel.charAt(0).toUpperCase() + d.data.maxModel.slice(1);
                    tooltip.html(`
                        <strong>Sector:</strong> ${d.data.sector}<br>
                        <strong>Occupation:</strong> ${d.data.name}<br>
                        <strong>Compensation:</strong> $${d.data.value.toFixed(2)}B<br>
                        <strong>Model Win Rate:</strong> ${d.data.maxWin}% (${modelName})
                    `);
                })
                .on('mousemove', function(event) {
                    tooltip
                        .style('left', (event.pageX + 15) + 'px')
                        .style('top', (event.pageY + 15) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.classed('visible', false);
                })
                .on('click', function(event, d) {
                    showModal(d.data);
                });

            // Add occupation labels
            const minWidthForLabel = 80;
            const minHeightForLabel = 40;

            cell.filter(d => (d.x1 - d.x0) > minWidthForLabel && (d.y1 - d.y0) > minHeightForLabel)
                .each(function(d) {
                    const g = d3.select(this);
                    const cellWidth = d.x1 - d.x0;
                    const cellHeight = d.y1 - d.y0;

                    // Occupation name (bold) at top
                    const nameText = g.append('text')
                        .attr('class', 'occupation-label occupation-name')
                        .attr('x', 5)
                        .attr('y', 15)
                        .text(d.data.name);

                    // Wrap text if needed
                    wrapText(nameText, cellWidth - 10);

                    // Compensation value at bottom
                    g.append('text')
                        .attr('class', 'occupation-label occupation-value')
                        .attr('x', 5)
                        .attr('y', cellHeight - 5)
                        .text(`$${d.data.value.toFixed(2)}B`);
                });

            // Add sector labels
            const sectors = root.children;
            sectors.forEach(sector => {
                const x0 = d3.min(sector.leaves(), d => d.x0);
                const y0 = d3.min(sector.leaves(), d => d.y0);
                const x1 = d3.max(sector.leaves(), d => d.x1);

                svg.append('text')
                    .attr('class', 'sector-label')
                    .attr('x', x0 + 5)
                    .attr('y', y0 - 5)
                    .text(sector.data.name);
            });

            // Create legend gradient
            const legendScale = d3.select('#legend-scale');
            const gradientSteps = 100;
            for (let i = 0; i < gradientSteps; i++) {
                const value = (i / (gradientSteps - 1)) * 100;
                legendScale.append('div')
                    .style('flex', '1')
                    .style('background-color', colorScale(value));
            }

            // Text wrapping function
            function wrapText(text, width) {
                const words = text.text().split(/\s+/);
                text.text('');

                let line = [];
                let lineNumber = 0;
                const lineHeight = 1.1;
                const y = text.attr('y');
                const dy = 0;

                let tspan = text.append('tspan')
                    .attr('x', text.attr('x'))
                    .attr('y', y)
                    .attr('dy', dy + 'em');

                words.forEach(word => {
                    line.push(word);
                    tspan.text(line.join(' '));
                    if (tspan.node().getComputedTextLength() > width && line.length > 1) {
                        line.pop();
                        tspan.text(line.join(' '));
                        line = [word];
                        lineNumber++;
                        tspan = text.append('tspan')
                            .attr('x', text.attr('x'))
                            .attr('y', y)
                            .attr('dy', lineNumber * lineHeight + dy + 'em')
                            .text(word);
                    }
                });
            }

            // Modal functionality
            const modal = document.getElementById('modal');
            const closeBtn = document.getElementsByClassName('close')[0];

            closeBtn.onclick = function() {
                modal.classList.remove('visible');
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.classList.remove('visible');
                }
            }

            window.addEventListener('keydown', function(event) {
                if (event.key === 'Escape' && modal.classList.contains('visible')) {
                    modal.classList.remove('visible');
                }
            });

            function showModal(data) {
                document.getElementById('modal-title').textContent = data.name;
                document.getElementById('modal-sector').textContent = `Sector: ${data.sector}`;
                const modelName = data.maxModel.charAt(0).toUpperCase() + data.maxModel.slice(1);
                document.getElementById('modal-stats').textContent =
                    `Compensation: $${data.value.toFixed(2)}B | Max Win Rate: ${data.maxWin}% (${modelName})`;

                const modalBody = document.getElementById('modal-body');
                modalBody.innerHTML = '';

                if (data.prompts && data.prompts.length > 0) {
                    data.prompts.forEach((prompt, index) => {
                        const promptItem = document.createElement('div');
                        promptItem.className = 'prompt-item';

                        const promptHeader = document.createElement('div');
                        promptHeader.className = 'prompt-header';
                        promptHeader.innerHTML = `
                            Task Evaluation Prompt ${data.prompts.length > 1 ? `#${index + 1}` : ''}
                            <span class="prompt-toggle">▼</span>
                        `;

                        const promptContent = document.createElement('div');
                        promptContent.className = 'prompt-content';
                        promptContent.textContent = prompt;

                        promptHeader.onclick = function() {
                            promptContent.classList.toggle('visible');
                            promptHeader.querySelector('.prompt-toggle').classList.toggle('open');
                        };

                        promptItem.appendChild(promptHeader);
                        promptItem.appendChild(promptContent);
                        modalBody.appendChild(promptItem);
                    });
                } else {
                    modalBody.innerHTML = '<p style="color: #999;">No task prompts available for this occupation.</p>';
                }

                modal.classList.add('visible');
            }

            // Handle window resize for responsive behavior
            let resizeTimer;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {
                    const newWidth = getContainerWidth();
                    const newHeight = newWidth / 2;

                    svg.attr('width', newWidth)
                        .attr('height', newHeight)
                        .attr('viewBox', [0, 0, newWidth, newHeight]);

                    width = newWidth;
                    height = newHeight;

                    // Redraw treemap
                    svg.selectAll('*').remove();
                    treemap.size([width, height]);
                    treemap(root);

                    // Redraw cells
                    const cell = svg.selectAll('g')
                        .data(root.leaves())
                        .join('g')
                        .attr('transform', d => `translate(${d.x0},${d.y0})`);

                    cell.append('rect')
                        .attr('class', 'cell')
                        .attr('width', d => d.x1 - d.x0)
                        .attr('height', d => d.y1 - d.y0)
                        .attr('fill', d => colorScale(d.data.maxWin))
                        .on('mouseover', function(event, d) {
                            tooltip.classed('visible', true);
                            const modelName = d.data.maxModel.charAt(0).toUpperCase() + d.data.maxModel.slice(1);
                            tooltip.html(`
                                <strong>Sector:</strong> ${d.data.sector}<br>
                                <strong>Occupation:</strong> ${d.data.name}<br>
                                <strong>Compensation:</strong> $${d.data.value.toFixed(2)}B<br>
                                <strong>Model Win Rate:</strong> ${d.data.maxWin}% (${modelName})
                            `);
                        })
                        .on('mousemove', function(event) {
                            tooltip
                                .style('left', (event.pageX + 15) + 'px')
                                .style('top', (event.pageY + 15) + 'px');
                        })
                        .on('mouseout', function() {
                            tooltip.classed('visible', false);
                        })
                        .on('click', function(event, d) {
                            showModal(d.data);
                        });

                    // Redraw labels
                    cell.filter(d => (d.x1 - d.x0) > minWidthForLabel && (d.y1 - d.y0) > minHeightForLabel)
                        .each(function(d) {
                            const g = d3.select(this);
                            const cellWidth = d.x1 - d.x0;
                            const cellHeight = d.y1 - d.y0;

                            const nameText = g.append('text')
                                .attr('class', 'occupation-label occupation-name')
                                .attr('x', 5)
                                .attr('y', 15)
                                .text(d.data.name);

                            wrapText(nameText, cellWidth - 10);

                            g.append('text')
                                .attr('class', 'occupation-label occupation-value')
                                .attr('x', 5)
                                .attr('y', cellHeight - 5)
                                .text(`$${d.data.value.toFixed(2)}B`);
                        });

                    // Redraw sector labels
                    const sectors = root.children;
                    sectors.forEach(sector => {
                        const x0 = d3.min(sector.leaves(), d => d.x0);
                        const y0 = d3.min(sector.leaves(), d => d.y0);

                        svg.append('text')
                            .attr('class', 'sector-label')
                            .attr('x', x0 + 5)
                            .attr('y', y0 - 5)
                            .text(sector.data.name);
                    });
                }, 250);
            });

        }).catch(error => {
            console.error('Error loading data:', error);
            document.getElementById('treemap').innerHTML =
                '<div style="color: red; text-align: center; padding: 40px;">Error loading data files. Please ensure compensation.csv, win.csv, and prompts.csv are in the same directory.</div>';
        });
    </script>
</body>
</html>
