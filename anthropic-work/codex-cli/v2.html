<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>AI → Engineer Productivity Patterns (Anthropic)</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,300..800&family=Fraunces:opsz,wght,SOFT,WONK@9..144,300..900,0..100,0..1&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />

    <style>
      :root {
        --bg0: #070a10;
        --bg1: #0b1325;
        --ink: #e9edff;
        --muted: rgba(233, 237, 255, 0.7);
        --glass: rgba(255, 255, 255, 0.06);
        --stroke: rgba(233, 237, 255, 0.16);
        --a: #9dffcb;
        --b: #7aa7ff;
        --c: #ff6fd8;
        --warn: #ffd166;
        --danger: #ff5e7d;
        --shadow: 0 12px 40px rgba(0, 0, 0, 0.38);
      }

      html,
      body {
        height: 100%;
        background: radial-gradient(1200px 700px at 15% 10%, rgba(122, 167, 255, 0.18), transparent 55%),
          radial-gradient(900px 560px at 88% 16%, rgba(255, 111, 216, 0.16), transparent 50%),
          radial-gradient(700px 520px at 70% 92%, rgba(157, 255, 203, 0.12), transparent 55%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        color: var(--ink);
        font-family: "Bricolage Grotesque", ui-sans-serif, system-ui, -apple-system, "Segoe UI", sans-serif;
      }

      .wrap {
        max-width: 1180px;
      }

      .hero {
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
      }

      .hero h1 {
        font-family: "Fraunces", ui-serif, Georgia, serif;
        font-variation-settings: "SOFT" 65, "WONK" 0;
        letter-spacing: 0.2px;
      }

      .subtle {
        color: var(--muted);
      }

      .pill {
        border: 1px solid var(--stroke);
        background: rgba(0, 0, 0, 0.18);
      }

      .nav-pills .nav-link {
        color: rgba(233, 237, 255, 0.78);
        border: 1px solid transparent;
      }

      .nav-pills .nav-link.active {
        background: linear-gradient(135deg, rgba(122, 167, 255, 0.28), rgba(157, 255, 203, 0.14));
        border: 1px solid rgba(233, 237, 255, 0.2);
        color: var(--ink);
      }

      .cardish {
        border: 1px solid var(--stroke);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
      }

      .chart-slot {
        height: 360px;
        border-radius: 16px;
        border: 1px solid rgba(233, 237, 255, 0.12);
        background: radial-gradient(800px 380px at 55% 40%, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.08));
        overflow: hidden;
        position: relative;
      }

      .chart-slot svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .tiny {
        font-size: 0.9rem;
      }

      .tag {
        font-size: 0.82rem;
        letter-spacing: 0.4px;
        color: rgba(233, 237, 255, 0.75);
      }

      .kbdish {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 0.85rem;
        padding: 0.08rem 0.45rem;
        border-radius: 0.55rem;
        border: 1px solid rgba(233, 237, 255, 0.18);
        background: rgba(0, 0, 0, 0.24);
        color: rgba(233, 237, 255, 0.92);
      }

      .slider {
        accent-color: var(--a);
      }

      .btn-ghost {
        border: 1px solid rgba(233, 237, 255, 0.22);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(233, 237, 255, 0.92);
      }

      .btn-ghost:hover {
        border-color: rgba(233, 237, 255, 0.35);
        background: rgba(255, 255, 255, 0.06);
      }

      .tooltipish {
        position: absolute;
        pointer-events: none;
        z-index: 50;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(233, 237, 255, 0.22);
        background: rgba(6, 10, 18, 0.88);
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
        color: rgba(233, 237, 255, 0.95);
        font-size: 0.92rem;
        line-height: 1.25;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 140ms ease, transform 140ms ease;
        max-width: 290px;
      }

      .tooltipish.show {
        opacity: 1;
        transform: translateY(0);
      }

      .tooltipish .t-title {
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .tooltipish .t-row {
        color: rgba(233, 237, 255, 0.78);
      }

      .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        display: inline-block;
        margin-right: 8px;
        vertical-align: -1px;
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
          transition: none !important;
          animation: none !important;
        }
      }
    </style>

  </head>

  <body>
    <main class="container-fluid py-4">
      <div class="wrap mx-auto">
        <section class="hero rounded-4 p-4 p-md-5 mb-4">
          <div class="d-flex flex-column flex-lg-row gap-4 align-items-lg-end justify-content-between">
            <div>
              <div class="tag mb-2">Interactive, synthetic-but-grounded illustration</div>
              <h1 class="mb-2">How AI reshapes engineer productivity at Anthropic</h1>
              <div class="subtle tiny mb-0">
                Built from the article’s reported shifts: Claude usage <span class="kbdish">28% → 59%</span>, self-reported boost
                <span class="kbdish">+20% → +50%</span>, “new work” <span class="kbdish">27%</span> of Claude-assisted, papercuts
                <span class="kbdish">8.6%</span>, autonomy <span class="kbdish">9.8 → 21.2</span> tool-call chains.
              </div>
            </div>

            <div class="pill rounded-4 p-3">
              <div class="d-flex align-items-center justify-content-between gap-3 mb-2">
                <div class="tiny">
                  <div class="fw-semibold">Before ↔ After</div>
                  <div class="subtle">Slide or press play</div>
                </div>
                <div class="d-flex align-items-center gap-2">
                  <button id="btn-play" class="btn btn-ghost btn-sm" type="button" aria-label="Play animation">
                    Play
                  </button>
                  <button id="btn-scrub" class="btn btn-ghost btn-sm" type="button" aria-label="Reset to before">
                    Reset
                  </button>
                </div>
              </div>
              <div class="d-flex align-items-center gap-3">
                <div class="tiny subtle" style="min-width: 90px">Before</div>
                <input id="global-t" class="form-range slider" type="range" min="0" max="1" value="0" step="0.001" />
                <div class="tiny subtle" style="min-width: 90px; text-align: right">After</div>
              </div>
            </div>
          </div>
        </section>

        <ul class="nav nav-pills gap-2 mb-3" id="pattern-tabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button
              class="nav-link active"
              id="tab-fullstack"
              data-bs-toggle="pill"
              data-bs-target="#pane-fullstack"
              type="button"
              role="tab"
              aria-controls="pane-fullstack"
              aria-selected="true"
            >
              1) More done, more full-stack
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button
              class="nav-link"
              id="tab-feedback"
              data-bs-toggle="pill"
              data-bs-target="#pane-feedback"
              type="button"
              role="tab"
              aria-controls="pane-feedback"
              aria-selected="false"
            >
              2) Faster learning & iteration
            </button>
          </li>
          <li class="nav-item" role="presentation">
            <button
              class="nav-link"
              id="tab-neglected"
              data-bs-toggle="pill"
              data-bs-target="#pane-neglected"
              type="button"
              role="tab"
              aria-controls="pane-neglected"
              aria-selected="false"
            >
              3) Tackling neglected work
            </button>
          </li>
        </ul>

        <div class="tab-content" id="pattern-tabs-content">
          <section class="tab-pane fade show active" id="pane-fullstack" role="tabpanel" aria-labelledby="tab-fullstack" tabindex="0">
            <div class="row g-3">
              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Role → Task expansion flow</div>
                      <div class="subtle tiny">
                        Metric: “Successful task outcomes per engineer-month” flowing from role to task type.
                      </div>
                    </div>
                    <span class="kbdish">Sankey</span>
                  </div>
                  <div class="chart-slot" id="chart-sankey"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Capability bloom</div>
                      <div class="subtle tiny">
                        Metric: % of engineers reporting “I can capably ship here” across domains.
                      </div>
                    </div>
                    <span class="kbdish">Polar</span>
                  </div>
                  <div class="chart-slot" id="chart-bloom"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Less time, more output</div>
                      <div class="subtle tiny">
                        Metric: self-reported time change vs output change by task category (Figure 2 style).
                      </div>
                    </div>
                    <span class="kbdish">Scatter</span>
                  </div>
                  <div class="chart-slot" id="chart-scatter"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Cross-stack contribution matrix</div>
                      <div class="subtle tiny">Metric: % of each role shipping work in each domain (heatmap morph).</div>
                    </div>
                    <span class="kbdish">Heatmap</span>
                  </div>
                  <div class="chart-slot" id="chart-matrix"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Breadth “fireflies”</div>
                      <div class="subtle tiny">Metric: domains touched per engineer-month (132 engineers, animated swarm).</div>
                    </div>
                    <span class="kbdish">Swarm</span>
                  </div>
                  <div class="chart-slot" id="chart-fireflies"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Claude task-mix compass</div>
                      <div class="subtle tiny">Metric: Claude Code task distribution shifts toward complex work (Figure 4 vibe).</div>
                    </div>
                    <span class="kbdish">Radial</span>
                  </div>
                  <div class="chart-slot" id="chart-compass"></div>
                </div>
              </div>
            </div>
          </section>

          <section class="tab-pane fade" id="pane-feedback" role="tabpanel" aria-labelledby="tab-feedback" tabindex="0">
            <div class="row g-3">
              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Feedback loop shrink</div>
                      <div class="subtle tiny">
                        Metric: end-to-end iteration cycle time (hours) across plan → implement → check → fix → coordinate.
                      </div>
                    </div>
                    <span class="kbdish">Loop</span>
                  </div>
                  <div class="chart-slot" id="chart-loop"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Autonomy dashboard</div>
                      <div class="subtle tiny">
                        Metric: task complexity, max consecutive tool calls, and human turns (Feb → Aug 2025).
                      </div>
                    </div>
                    <span class="kbdish">Gauges</span>
                  </div>
                  <div class="chart-slot" id="chart-autonomy"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Time-to-competence distribution</div>
                      <div class="subtle tiny">
                        Metric: days to ship a first “unfamiliar-domain” change (synthetic, aligned to interviews).
                      </div>
                    </div>
                    <span class="kbdish">Histogram</span>
                  </div>
                  <div class="chart-slot" id="chart-learning"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">“A million horses” branching</div>
                      <div class="subtle tiny">Metric: parallel hypothesis exploration (branches grow + particles race).</div>
                    </div>
                    <span class="kbdish">Xeno</span>
                  </div>
                  <div class="chart-slot" id="chart-horses"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Turn-taking barcode</div>
                      <div class="subtle tiny">Metric: human turns shrink while autonomous tool chains lengthen.</div>
                    </div>
                    <span class="kbdish">Barcode</span>
                  </div>
                  <div class="chart-slot" id="chart-barcode"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Learning curve shift</div>
                      <div class="subtle tiny">Metric: “effective proficiency” climbs faster with tighter feedback loops.</div>
                    </div>
                    <span class="kbdish">Curves</span>
                  </div>
                  <div class="chart-slot" id="chart-curves"></div>
                </div>
              </div>
            </div>
          </section>

          <section class="tab-pane fade" id="pane-neglected" role="tabpanel" aria-labelledby="tab-neglected" tabindex="0">
            <div class="row g-3">
              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Work iceberg</div>
                      <div class="subtle tiny">
                        Metric: share of “quality-of-life” work (docs/tests/tools/papercuts) that rises above the priority line.
                      </div>
                    </div>
                    <span class="kbdish">Xeno</span>
                  </div>
                  <div class="chart-slot" id="chart-iceberg"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Papercut backlog burn-down</div>
                      <div class="subtle tiny">
                        Metric: open papercuts over 12 weeks; “papercut fixes” ≈ <span class="kbdish">8.6%</span> of Claude Code tasks.
                      </div>
                    </div>
                    <span class="kbdish">Timeline</span>
                  </div>
                  <div class="chart-slot" id="chart-burndown"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Work portfolio shift</div>
                      <div class="subtle tiny">
                        Metric: output split into “core”, “accelerated core”, and “new otherwise-not-done”.
                      </div>
                    </div>
                    <span class="kbdish">Area</span>
                  </div>
                  <div class="chart-slot" id="chart-portfolio"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Quality-of-life flywheel</div>
                      <div class="subtle tiny">Metric: papercut fixes reduce friction → frees time → fixes more papercuts.</div>
                    </div>
                    <span class="kbdish">Xeno</span>
                  </div>
                  <div class="chart-slot" id="chart-flywheel"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Toil budget waffle</div>
                      <div class="subtle tiny">Metric: “activation energy” drops, reallocating hours into neglected work.</div>
                    </div>
                    <span class="kbdish">Waffle</span>
                  </div>
                  <div class="chart-slot" id="chart-waffle"></div>
                </div>
              </div>

              <div class="col-12 col-lg-4">
                <div class="cardish rounded-4 p-3 h-100">
                  <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                    <div>
                      <div class="fw-semibold">Backlog age raincloud</div>
                      <div class="subtle tiny">Metric: completed “neglected” items skew younger (stale tail shrinks).</div>
                    </div>
                    <span class="kbdish">Rain</span>
                  </div>
                  <div class="chart-slot" id="chart-raincloud"></div>
                </div>
              </div>
            </div>
          </section>
        </div>

        <footer class="subtle tiny mt-4 pb-2">
          Notes: Data is synthetic and calibrated to the article’s reported aggregates; hover charts for exact values.
          If you prefer a different “before” anchor (e.g. Feb 2025 vs Aug 2025 vs 12 months ago), say so and I’ll re-balance.
        </footer>
      </div>
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

    <script>
      // @ts-check
      const d3Sankey = d3.sankey;
      const sankeyLinkHorizontal = d3.sankeyLinkHorizontal;

      const $ = (s, el = document) => el.querySelector(s);
      const clamp01 = (x) => Math.max(0, Math.min(1, x));
      const lerp = (a, b, t) => a + (b - a) * t;
      const fmt = d3.format(".1f");
      const fmt0 = d3.format(".0f");
      const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

      const theme = {
        ink: "rgba(233,237,255,0.92)",
        muted: "rgba(233,237,255,0.70)",
        grid: "rgba(233,237,255,0.12)",
        stroke: "rgba(233,237,255,0.18)",
        a: "#9dffcb",
        b: "#7aa7ff",
        c: "#ff6fd8",
        warn: "#ffd166",
        danger: "#ff5e7d",
      };

      const tooltip = (() => {
        const el = document.createElement("div");
        el.className = "tooltipish";
        document.body.appendChild(el);
        const show = (html, x, y) => {
          el.innerHTML = html;
          el.style.left = `${x + 12}px`;
          el.style.top = `${y + 12}px`;
          el.classList.add("show");
        };
        const move = (x, y) => {
          el.style.left = `${x + 12}px`;
          el.style.top = `${y + 12}px`;
        };
        const hide = () => el.classList.remove("show");
        return { show, move, hide };
      })();

      const state = {
        t: 0,
        playing: false,
        raf: /** @type {number|null} */ (null),
      };

      const safeRect = (el) => {
        const rect = el.getBoundingClientRect();
        if (rect.width < 10 || rect.height < 10) return null; // hidden (Bootstrap tabs) or not yet laid out
        return rect;
      };

      // ---- Synthetic data (anchored to the article’s reported aggregates) ----
      const DATA = (() => {
        // Pattern 1: “More full-stack” — role → task expansion (values are relative volume).
        const roles = ["Backend", "Frontend", "Security", "Research"];
        const tasks = ["Debugging", "Code understanding", "New features", "Design/planning", "Front-end", "Databases", "Infra/DevOps", "Data viz", "Docs/tests", "Papercuts"];

        const roleColor = d3.scaleOrdinal(roles, [theme.b, theme.c, theme.warn, theme.a]);
        const taskColor = d3
          .scaleOrdinal(tasks, [
            "#c8b6ff",
            "#8ecae6",
            "#80ed99",
            "#ffd166",
            "#ff6fd8",
            "#7aa7ff",
            "#9dffcb",
            "#ff9f1c",
            "#a0c4ff",
            "#ff5e7d",
          ])
          .unknown(theme.muted);

        /** @type {{nodes: {name: string, kind: "role"|"task"}[], linksBefore: {source: string, target: string, value: number}[], linksAfter: {source: string, target: string, value: number}[]}} */
        const flow = {
          nodes: [...roles.map((r) => ({ name: r, kind: "role" })), ...tasks.map((t) => ({ name: t, kind: "task" }))],
          linksBefore: [
            { source: "Backend", target: "New features", value: 34 },
            { source: "Backend", target: "Debugging", value: 20 },
            { source: "Backend", target: "Databases", value: 16 },
            { source: "Backend", target: "Infra/DevOps", value: 10 },
            { source: "Backend", target: "Front-end", value: 4 },
            { source: "Backend", target: "Data viz", value: 3 },
            { source: "Backend", target: "Docs/tests", value: 6 },
            { source: "Backend", target: "Papercuts", value: 2 },
            { source: "Frontend", target: "New features", value: 18 },
            { source: "Frontend", target: "Front-end", value: 28 },
            { source: "Frontend", target: "Debugging", value: 14 },
            { source: "Frontend", target: "Code understanding", value: 9 },
            { source: "Frontend", target: "Data viz", value: 6 },
            { source: "Frontend", target: "Docs/tests", value: 5 },
            { source: "Frontend", target: "Papercuts", value: 3 },
            { source: "Security", target: "Code understanding", value: 30 },
            { source: "Security", target: "Debugging", value: 16 },
            { source: "Security", target: "Infra/DevOps", value: 10 },
            { source: "Security", target: "New features", value: 8 },
            { source: "Security", target: "Design/planning", value: 6 },
            { source: "Security", target: "Docs/tests", value: 4 },
            { source: "Research", target: "New features", value: 20 },
            { source: "Research", target: "Data viz", value: 18 },
            { source: "Research", target: "Debugging", value: 10 },
            { source: "Research", target: "Code understanding", value: 12 },
            { source: "Research", target: "Design/planning", value: 6 },
            { source: "Research", target: "Front-end", value: 4 },
            { source: "Research", target: "Docs/tests", value: 3 },
          ],
          linksAfter: [
            // Overall “more done”: we increase totals ~50–70% and widen cross-domain links.
            { source: "Backend", target: "New features", value: 56 },
            { source: "Backend", target: "Debugging", value: 28 },
            { source: "Backend", target: "Databases", value: 22 },
            { source: "Backend", target: "Infra/DevOps", value: 16 },
            { source: "Backend", target: "Front-end", value: 12 },
            { source: "Backend", target: "Data viz", value: 8 },
            { source: "Backend", target: "Docs/tests", value: 12 },
            { source: "Backend", target: "Papercuts", value: 8 },
            { source: "Frontend", target: "New features", value: 30 },
            { source: "Frontend", target: "Front-end", value: 40 },
            { source: "Frontend", target: "Debugging", value: 22 },
            { source: "Frontend", target: "Code understanding", value: 14 },
            { source: "Frontend", target: "Data viz", value: 12 },
            { source: "Frontend", target: "Databases", value: 8 },
            { source: "Frontend", target: "Docs/tests", value: 10 },
            { source: "Frontend", target: "Papercuts", value: 6 },
            { source: "Security", target: "Code understanding", value: 44 },
            { source: "Security", target: "Debugging", value: 22 },
            { source: "Security", target: "Infra/DevOps", value: 16 },
            { source: "Security", target: "New features", value: 16 },
            { source: "Security", target: "Design/planning", value: 14 },
            { source: "Security", target: "Docs/tests", value: 8 },
            { source: "Security", target: "Papercuts", value: 6 },
            { source: "Research", target: "New features", value: 38 },
            { source: "Research", target: "Data viz", value: 30 },
            { source: "Research", target: "Debugging", value: 16 },
            { source: "Research", target: "Code understanding", value: 18 },
            { source: "Research", target: "Design/planning", value: 14 },
            { source: "Research", target: "Front-end", value: 14 },
            { source: "Research", target: "Docs/tests", value: 8 },
            { source: "Research", target: "Papercuts", value: 6 },
          ],
        };

        // Capability bloom: % of engineers reporting they can ship in the domain (synthetic, aligned to “more full-stack”).
        const bloom = [
          { domain: "Backend", before: 82, after: 88, color: roleColor("Backend") },
          { domain: "Testing", before: 52, after: 71, color: "#a0c4ff" },
          { domain: "Docs", before: 46, after: 66, color: "#c8b6ff" },
          { domain: "Databases", before: 42, after: 58, color: "#7aa7ff" },
          { domain: "Infra/DevOps", before: 44, after: 61, color: "#9dffcb" },
          { domain: "Security review", before: 31, after: 46, color: "#ffd166" },
          { domain: "Front-end", before: 34, after: 56, color: roleColor("Frontend") },
          { domain: "Data viz", before: 24, after: 45, color: "#ff9f1c" },
        ];

        // Figure-2-like: time change vs output change by task (in %).
        const taskImpact = [
          { task: "Debugging", freq: 0.55, time: -12, output: 46, color: taskColor("Debugging") },
          { task: "Code understanding", freq: 0.42, time: -8, output: 38, color: taskColor("Code understanding") },
          { task: "New features", freq: 0.37, time: -6, output: 62, color: taskColor("New features") },
          { task: "Refactoring", freq: 0.28, time: -10, output: 34, color: "#bdb2ff" },
          { task: "Front-end dev", freq: 0.17, time: -2, output: 40, color: taskColor("Front-end") },
          { task: "Data science", freq: 0.14, time: 2, output: 28, color: "#ff9f1c" },
          { task: "Design/planning", freq: 0.12, time: -1, output: 14, color: taskColor("Design/planning") },
        ];

        // Pattern 2: feedback loop stage times (hours); anchored to “weeks → hours” anecdote.
        const loop = {
          stages: [
            { name: "Plan", color: theme.warn, beforeHrs: 2.6, afterHrs: 1.1 },
            { name: "Implement", color: theme.a, beforeHrs: 6.0, afterHrs: 2.2 },
            { name: "Run/Check", color: theme.b, beforeHrs: 2.1, afterHrs: 0.8 },
            { name: "Fix/Polish", color: theme.c, beforeHrs: 3.6, afterHrs: 1.3 },
            { name: "Coordinate", color: theme.danger, beforeHrs: 8.0, afterHrs: 1.2 },
          ],
        };

        // Pattern 2: autonomy dashboard metrics from Figure 3 (explicit in article).
        const autonomy = {
          metrics: [
            { key: "Complexity", unit: "/ 5", before: 3.2, after: 3.8, domain: [1, 5], color: theme.warn, direction: "up" },
            { key: "Max tool-call chain", unit: "", before: 9.8, after: 21.2, domain: [0, 25], color: theme.a, direction: "up" },
            { key: "Human turns", unit: "", before: 6.2, after: 4.1, domain: [0, 10], color: theme.danger, direction: "down" },
          ],
          note: "Feb 2025 → Aug 2025 (200k Claude Code transcripts)",
        };

        // Pattern 2: time-to-competence distribution (days to ship in unfamiliar domain).
        const seeded = d3.randomLcg(0.48271);
        const randLogNorm = (mu, sigma) => {
          const r = d3.randomLogNormal.source(seeded)(mu, sigma);
          return () => Math.max(0.25, Math.min(28, r()));
        };
        const n = 220;
        const beforeDays = d3.range(n).map(randLogNorm(Math.log(7.5), 0.55));
        const afterDays = d3.range(n).map(randLogNorm(Math.log(2.7), 0.60));

        // Pattern 1: cross-stack matrix (role x domain) in % (synthetic, aligned to “more full-stack”).
        const domains = ["Front-end", "Databases", "Infra/DevOps", "Testing", "Docs", "Data viz", "Security review"];
        const matrix = {
          roles,
          domains,
          before: {
            Backend: { "Front-end": 14, Databases: 62, "Infra/DevOps": 44, Testing: 48, Docs: 36, "Data viz": 18, "Security review": 22 },
            Frontend: { "Front-end": 78, Databases: 22, "Infra/DevOps": 18, Testing: 46, Docs: 34, "Data viz": 28, "Security review": 16 },
            Security: { "Front-end": 12, Databases: 18, "Infra/DevOps": 36, Testing: 24, Docs: 22, "Data viz": 10, "Security review": 74 },
            Research: { "Front-end": 16, Databases: 20, "Infra/DevOps": 16, Testing: 22, Docs: 18, "Data viz": 64, "Security review": 12 },
          },
          after: {
            Backend: { "Front-end": 34, Databases: 70, "Infra/DevOps": 58, Testing: 62, Docs: 52, "Data viz": 32, "Security review": 30 },
            Frontend: { "Front-end": 84, Databases: 38, "Infra/DevOps": 30, Testing: 58, Docs: 48, "Data viz": 42, "Security review": 24 },
            Security: { "Front-end": 22, Databases: 30, "Infra/DevOps": 52, Testing: 36, Docs: 34, "Data viz": 22, "Security review": 82 },
            Research: { "Front-end": 36, Databases: 34, "Infra/DevOps": 28, Testing: 34, Docs: 30, "Data viz": 74, "Security review": 18 },
          },
        };

        // Pattern 1: per-engineer breadth (domains touched per month), 132 engineers (survey size).
        const nEng = 132;
        const pick = (weights) => {
          const total = d3.sum(Object.values(weights));
          const r = seeded() * total;
          let acc = 0;
          for (const [k, w] of Object.entries(weights)) {
            acc += w;
            if (r <= acc) return Number(k);
          }
          return Number(Object.keys(weights)[0]);
        };
        const breadthWeightsBefore = { 1: 0.22, 2: 0.34, 3: 0.24, 4: 0.14, 5: 0.05, 6: 0.01 };
        const breadthWeightsAfter = { 1: 0.10, 2: 0.22, 3: 0.28, 4: 0.22, 5: 0.13, 6: 0.05 };
        const breadth = d3.range(nEng).map((i) => ({
          i,
          before: pick(breadthWeightsBefore),
          after: pick(breadthWeightsAfter),
          role: roles[Math.floor(seeded() * roles.length)],
        }));

        // Pattern 1: Claude Code task distribution shift (Figure 4 anchored deltas).
        // Known from article: new features 14.3→36.9, design/planning 1.0→9.9.
        // Others are plausible complements that keep totals 100.
        const taskMix = {
          keys: ["New features", "Debugging", "Code understanding", "Refactoring", "Infra/DevOps", "Front-end", "Data science", "Design/planning", "Docs/tests"],
          before: {
            "New features": 14.3,
            Debugging: 26.5,
            "Code understanding": 24.0,
            Refactoring: 9.2,
            "Infra/DevOps": 12.0,
            "Front-end": 3.6,
            "Data science": 5.1,
            "Design/planning": 1.0,
            "Docs/tests": 4.3,
          },
          after: {
            "New features": 36.9,
            Debugging: 20.5,
            "Code understanding": 16.2,
            Refactoring: 7.4,
            "Infra/DevOps": 7.6,
            "Front-end": 4.9,
            "Data science": 4.2,
            "Design/planning": 9.9,
            "Docs/tests": 2.4,
          },
        };

        // Pattern 3: iceberg — “neglected” work becoming visible.
        const iceberg = {
          categories: [
            { name: "Roadmap features", color: theme.a, before: 0.52, after: 0.44 },
            { name: "High-stakes fixes", color: theme.b, before: 0.20, after: 0.18 },
            { name: "Docs & tests", color: "#c8b6ff", before: 0.10, after: 0.15 },
            { name: "Tools & dashboards", color: theme.c, before: 0.05, after: 0.10 },
            { name: "Papercuts", color: theme.danger, before: 0.03, after: 0.07 },
          ],
          visibleLine: 0.62, // visual “priority line”
        };

        // Pattern 3: papercut backlog over 12 weeks.
        const weeks = d3.range(0, 13).map((i) => ({ week: i }));
        const papercutsBefore = weeks.map(({ week }) => ({ week, open: Math.round(240 - 2.2 * week - (week > 8 ? 4 : 0)) }));
        const papercutsAfter = weeks.map(({ week }) => ({ week, open: Math.max(52, Math.round(240 - 15.8 * week - (week > 6 ? 12 : 0))) }));

        // Pattern 3: output portfolio shift over 12 months (synthetic, anchored to usage + productivity + new-work share).
        // Now: usage ~59% and "new work" ~27% of Claude-assisted => ~16% of total output is "new".
        // Earlier: usage ~28% and lower confidence => ~6% of total output is "new".
        const months = d3.range(0, 12).map((i) => i);
        const portfolio = months.map((m) => {
          const t = m / 11;
          const newShare = lerp(0.06, 0.16, t);
          const accelShare = lerp(0.18, 0.32, t);
          const coreShare = Math.max(0, 1 - newShare - accelShare);
          return { m, core: coreShare, accel: accelShare, novel: newShare };
        });

        // Pattern 2: learning curve shift (synthetic).
        const curve = d3.range(0, 15).map((day) => {
          const before = 100 * (1 - Math.exp(-day / 6.4));
          const after = 100 * (1 - Math.exp(-day / 3.1));
          const jitter = (seeded() - 0.5) * 2.2;
          return { day, before: Math.min(100, before + jitter), after: Math.min(100, after + jitter) };
        });

        // Pattern 2: “turn-taking” barcode synthesis from means.
        const makeTranscript = (humanTurns, toolChainMax) => {
          const segments = [];
          const totalSeg = humanTurns + toolChainMax;
          for (let i = 0; i < totalSeg; i++) {
            const isHuman = i % Math.max(1, Math.round(totalSeg / Math.max(1, humanTurns))) === 0 && segments.filter((s) => s.kind === "human").length < humanTurns;
            segments.push({ kind: isHuman ? "human" : "tool", w: isHuman ? 1.4 : 1.0 + (seeded() * 0.7) });
          }
          return segments;
        };
        const barcode = {
          before: makeTranscript(6.2, 9.8),
          after: makeTranscript(4.1, 21.2),
        };

        // Pattern 3: toil budget waffle (100 units).
        const waffle = {
          keys: ["Core features", "Meetings", "Debug toil", "Docs/tests", "Tools/dashboards", "Papercuts", "Exploration"],
          before: { "Core features": 44, Meetings: 20, "Debug toil": 16, "Docs/tests": 8, "Tools/dashboards": 4, Papercuts: 3, Exploration: 5 },
          after: { "Core features": 40, Meetings: 16, "Debug toil": 14, "Docs/tests": 12, "Tools/dashboards": 7, Papercuts: 6, Exploration: 5 },
        };

        // Pattern 3: backlog-age distribution (days) for completed neglected items (synthetic).
        const randGamma = (k, theta) => d3.randomGamma.source(seeded)(k, theta);
        const ageData = {
          categories: ["Docs/tests", "Tools/dashboards", "Papercuts"],
          before: [],
          after: [],
        };
        for (const c of ageData.categories) {
          const base = c === "Papercuts" ? 14 : c === "Tools/dashboards" ? 22 : 18;
          const n = 120;
          const genB = randGamma(2.1, base / 2.1);
          const genA = randGamma(2.0, (base * 0.55) / 2.0);
          for (let i = 0; i < n; i++) ageData.before.push({ c, days: Math.min(120, genB()) });
          for (let i = 0; i < n; i++) ageData.after.push({ c, days: Math.min(120, genA()) });
        }

        // Pattern 3: flywheel parameters (synthetic, framed as “friction minutes/day”).
        const flywheel = {
          before: { frictionMin: 52, papercutsPerWeek: 6, reclaimedMin: 0 },
          after: { frictionMin: 28, papercutsPerWeek: 18, reclaimedMin: 34 },
        };

        return {
          flow,
          bloom,
          taskImpact,
          loop,
          autonomy,
          learning: { beforeDays, afterDays },
          matrix,
          breadth,
          taskMix,
          curve,
          barcode,
          iceberg,
          burndown: { weeks, papercutsBefore, papercutsAfter },
          portfolio,
          waffle,
          ageData,
          flywheel,
          palette: { roleColor, taskColor },
        };
      })();

      // ---- Chart base helpers ----
      const observeSize = (el, on) => {
        const ro = new ResizeObserver(() => on());
        ro.observe(el);
        return () => ro.disconnect();
      };

      const makeSvg = (el) => d3.select(el).append("svg").attr("role", "img").attr("aria-label", el.dataset?.ariaLabel ?? "chart");

      const pointer = (event, node) => {
        const [x, y] = d3.pointer(event, node);
        const rect = node.getBoundingClientRect();
        return { x: rect.left + x, y: rect.top + y };
      };

      // ---- Chart 1: Sankey role → task expansion ----
      const sankeyChart = (() => {
        const el = $("#chart-sankey");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const gLinks = g.append("g");
        const gNodes = g.append("g");
        const gLabel = g.append("g");

        const pad = { l: 14, r: 14, t: 12, b: 16 };
        let w = 0;
        let h = 0;
        let sankeyLayout = null;
        let layoutBefore = null;
        let layoutAfter = null;

        const buildLayout = (links) => {
          const nodes = DATA.flow.nodes.map((d) => ({ ...d }));
          const nodeByName = new Map(nodes.map((n, i) => [n.name, i]));
          const normalizedLinks = links.map((l) => ({
            source: nodeByName.get(l.source),
            target: nodeByName.get(l.target),
            value: l.value,
          }));

          const s = d3Sankey()
            .nodeWidth(14)
            .nodePadding(12)
            .extent([
              [pad.l, pad.t],
              [w - pad.r, h - pad.b],
            ]);

          const graph = s({
            nodes,
            links: normalizedLinks,
          });
          return { graph, s };
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          sankeyLayout = d3Sankey()
            .nodeWidth(14)
            .nodePadding(12)
            .extent([
              [pad.l, pad.t],
              [w - pad.r, h - pad.b],
            ]);

          layoutBefore = buildLayout(DATA.flow.linksBefore).graph;
          layoutAfter = buildLayout(DATA.flow.linksAfter).graph;

          const nodes = layoutAfter.nodes; // positions are very similar; use after for stable labels.
          const nodeSel = gNodes.selectAll("rect").data(nodes, (d) => d.name);
          nodeSel
            .join((enter) =>
              enter
                .append("rect")
                .attr("rx", 7)
                .attr("ry", 7)
                .attr("fill", (d) => (d.kind === "role" ? DATA.palette.roleColor(d.name) : DATA.palette.taskColor(d.name)))
                .attr("stroke", "rgba(233,237,255,0.18)")
            )
            .attr("x", (d) => d.x0)
            .attr("y", (d) => d.y0)
            .attr("width", (d) => Math.max(10, d.x1 - d.x0))
            .attr("height", (d) => Math.max(10, d.y1 - d.y0))
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              const totalBefore = d3.sum(layoutBefore.links, (l) => (layoutBefore.nodes[l.source.index].name === d.name || layoutBefore.nodes[l.target.index].name === d.name ? l.value : 0));
              const totalAfter = d3.sum(layoutAfter.links, (l) => (layoutAfter.nodes[l.source.index].name === d.name || layoutAfter.nodes[l.target.index].name === d.name ? l.value : 0));
              tooltip.show(
                `<div class="t-title">${d.name}</div>
                 <div class="t-row">Before volume: <span class="kbdish">${fmt0(totalBefore)}</span></div>
                 <div class="t-row">After volume: <span class="kbdish">${fmt0(totalAfter)}</span></div>
                 <div class="t-row">Reads as “breadth + throughput” together.</div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          const labelSel = gLabel.selectAll("text").data(nodes, (d) => d.name);
          labelSel
            .join((enter) =>
              enter
                .append("text")
                .attr("fill", theme.ink)
                .attr("font-size", 12)
                .attr("font-weight", 650)
                .attr("opacity", 0.92)
            )
            .attr("x", (d) => (d.kind === "role" ? d.x0 + 18 : d.x0 - 10))
            .attr("y", (d) => (d.y0 + d.y1) / 2)
            .attr("text-anchor", (d) => (d.kind === "role" ? "start" : "end"))
            .attr("dominant-baseline", "middle")
            .text((d) => d.name);

          g.append("text")
            .attr("x", pad.l)
            .attr("y", h - 8)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Hover nodes/links • Slide to morph (Before → After)");
        };

        const update = (t) => {
          if (!layoutBefore || !layoutAfter) return;
          const t0 = clamp01(t);

          const byKey = (l) => `${layoutAfter.nodes[l.source.index].name}→${layoutAfter.nodes[l.target.index].name}`;
          const beforeMap = new Map(layoutBefore.links.map((l) => [byKey(l), l]));
          const afterMap = new Map(layoutAfter.links.map((l) => [byKey(l), l]));
          const keys = [...new Set([...beforeMap.keys(), ...afterMap.keys()])];

          /** @type {{key: string, b: any|null, a: any|null}[]} */
          const merged = keys.map((key) => ({ key, b: beforeMap.get(key) ?? null, a: afterMap.get(key) ?? null }));

          // Render links with interpolated thickness, but stable geometry from "after" layout for readability.
          const linkSel = gLinks.selectAll("path").data(merged, (d) => d.key);
          linkSel
            .join((enter) =>
              enter
                .append("path")
                .attr("fill", "none")
                .attr("stroke-opacity", 0.58)
                .attr("stroke-linecap", "round")
                .attr("stroke", (d) => {
                  const a = d.a ?? d.b;
                  const src = a ? layoutAfter.nodes[a.source.index].name : "";
                  return DATA.palette.roleColor(src) ?? theme.ink;
                })
            )
            .attr("d", (d) => {
              const a = d.a ?? d.b;
              if (!a) return "";
              return sankeyLinkHorizontal()(a);
            })
            .attr("stroke-width", (d) => {
              const b = d.b?.value ?? 0;
              const a = d.a?.value ?? 0;
              return Math.max(0.8, lerp(b, a, t0));
            })
            .on("mousemove", (event, d) => {
              const a = d.a ?? d.b;
              if (!a) return;
              const src = layoutAfter.nodes[a.source.index].name;
              const dst = layoutAfter.nodes[a.target.index].name;
              const b = d.b?.value ?? 0;
              const av = d.a?.value ?? 0;
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${src} → ${dst}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt0(b)}</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt0(av)}</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 2: Capability bloom (polar bars) ----
      const bloomChart = (() => {
        const el = $("#chart-bloom");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const gLegend = svg.append("g");

        let w = 0;
        let h = 0;
        let cx = 0;
        let cy = 0;
        let r0 = 0;
        let r1 = 0;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);

          cx = w * 0.52;
          cy = h * 0.52;
          r0 = Math.min(w, h) * 0.14;
          r1 = Math.min(w, h) * 0.40;

          g.attr("transform", `translate(${cx},${cy})`);

          const ring = d3.range(3).map((i) => r0 + (i + 1) * ((r1 - r0) / 3));
          g.selectAll("circle.grid")
            .data(ring)
            .join("circle")
            .attr("class", "grid")
            .attr("r", (d) => d)
            .attr("fill", "none")
            .attr("stroke", theme.grid)
            .attr("stroke-dasharray", "3,6")
            .attr("opacity", 0.9);

          const petals = DATA.bloom;
          const angle = d3.scaleBand().domain(petals.map((d) => d.domain)).range([-(Math.PI * 0.94), Math.PI * 0.94]).padding(0.14);
          const rad = d3.scaleLinear().domain([0, 100]).range([r0, r1]);

          const arc = d3
            .arc()
            .innerRadius(r0)
            .cornerRadius(10)
            .padAngle(0.02);

          const petalSel = g.selectAll("path.petal").data(petals, (d) => d.domain);
          petalSel
            .join((enter) =>
              enter
                .append("path")
                .attr("class", "petal")
                .attr("fill", (d) => d.color)
                .attr("fill-opacity", 0.72)
                .attr("stroke", "rgba(233,237,255,0.14)")
                .attr("stroke-width", 1)
                .on("mousemove", (event, d) => {
                  const pos = pointer(event, el);
                  tooltip.show(
                    `<div class="t-title">${d.domain}</div>
                     <div class="t-row">Before: <span class="kbdish">${fmt0(d.before)}%</span></div>
                     <div class="t-row">After: <span class="kbdish">${fmt0(d.after)}%</span></div>`,
                    pos.x,
                    pos.y
                  );
                })
                .on("mouseleave", () => tooltip.hide())
            )
            .attr("d", (d) =>
              arc({
                startAngle: angle(d.domain),
                endAngle: angle(d.domain) + angle.bandwidth(),
                outerRadius: rad(d.before),
              })
            );

          const labelSel = g.selectAll("text.lbl").data(petals, (d) => d.domain);
          labelSel
            .join((enter) =>
              enter
                .append("text")
                .attr("class", "lbl")
                .attr("fill", theme.ink)
                .attr("font-size", 11)
                .attr("font-weight", 650)
                .attr("opacity", 0.92)
            )
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("transform", (d) => {
              const a = angle(d.domain) + angle.bandwidth() / 2;
              const rr = r1 + 16;
              const x = Math.cos(a) * rr;
              const y = Math.sin(a) * rr;
              return `translate(${x},${y})`;
            })
            .text((d) => d.domain);

          g.selectAll("text.center")
            .data([0])
            .join("text")
            .attr("class", "center")
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 12)
            .text("Org capability footprint");

          gLegend
            .attr("transform", `translate(${14},${18})`)
            .selectAll("text")
            .data([0])
            .join("text")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Petals grow as more engineers feel comfortable shipping outside their “home” domain.");
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const angle = d3.scaleBand().domain(DATA.bloom.map((d) => d.domain)).range([-(Math.PI * 0.94), Math.PI * 0.94]).padding(0.14);
          const r0Now = r0;
          const r1Now = r1;
          const rad = d3.scaleLinear().domain([0, 100]).range([r0Now, r1Now]);
          const arc = d3
            .arc()
            .innerRadius(r0Now)
            .cornerRadius(10)
            .padAngle(0.02);

          g.selectAll("path.petal").attr("d", (d) =>
            arc({
              startAngle: angle(d.domain),
              endAngle: angle(d.domain) + angle.bandwidth(),
              outerRadius: rad(lerp(d.before, d.after, t0)),
            })
          );
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 3: Time vs Output scatter (Figure 2 vibe) ----
      const scatterChart = (() => {
        const el = $("#chart-scatter");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 44, r: 16, t: 18, b: 36 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);

          x = d3.scaleLinear().domain([-25, 12]).range([pad.l, w - pad.r]);
          y = d3.scaleLinear().domain([0, 80]).range([h - pad.b, pad.t]);
          const r = d3.scaleSqrt().domain([0.1, 0.6]).range([6, 18]);

          g.selectAll("*").remove();

          // Grid + axes
          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(
              d3
                .axisBottom(x)
                .ticks(6)
                .tickSizeOuter(0)
                .tickFormat((d) => `${d}%`)
            )
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("g")
            .attr("transform", `translate(${pad.l},0)`)
            .call(
              d3
                .axisLeft(y)
                .ticks(5)
                .tickSizeOuter(0)
                .tickFormat((d) => `${d}%`)
            )
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text")
            .attr("x", (pad.l + (w - pad.r)) / 2)
            .attr("y", h - 10)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Time spent change (Claude-assisted vs not)  →");

          g.append("text")
            .attr("x", 14)
            .attr("y", (pad.t + (h - pad.b)) / 2)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .attr("transform", `rotate(-90,14,${(pad.t + (h - pad.b)) / 2})`)
            .text("↑ Output volume change");

          g.append("line")
            .attr("x1", x(0))
            .attr("x2", x(0))
            .attr("y1", pad.t)
            .attr("y2", h - pad.b)
            .attr("stroke", "rgba(233,237,255,0.18)")
            .attr("stroke-dasharray", "4,6");

          const dots = g.append("g").selectAll("circle").data(DATA.taskImpact, (d) => d.task);
          dots
            .join("circle")
            .attr("cx", x(0))
            .attr("cy", y(0))
            .attr("r", (d) => r(d.freq))
            .attr("fill", (d) => d.color)
            .attr("fill-opacity", 0.78)
            .attr("stroke", "rgba(233,237,255,0.18)")
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${d.task}</div>
                 <div class="t-row">Daily use proxy: <span class="kbdish">${fmt0(d.freq * 100)}%</span></div>
                 <div class="t-row">Time change: <span class="kbdish">${d.time > 0 ? "+" : ""}${fmt0(d.time)}%</span></div>
                 <div class="t-row">Output change: <span class="kbdish">+${fmt0(d.output)}%</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          g.selectAll("circle")
            .attr("cx", (d) => x(lerp(0, d.time, ease)))
            .attr("cy", (d) => y(lerp(0, d.output, ease)));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 4: Feedback loop shrink (animated ring) ----
      const loopChart = (() => {
        const el = $("#chart-loop");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const gText = svg.append("g");
        let w = 0;
        let h = 0;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.attr("transform", `translate(${w / 2},${h / 2})`);
          gText.attr("transform", `translate(${w / 2},${h / 2})`);

          const rr0 = Math.min(w, h) * 0.18;
          const rr1 = Math.min(w, h) * 0.40;

          g.selectAll("*").remove();
          gText.selectAll("*").remove();

          const arc = d3.arc().innerRadius(rr0).outerRadius(rr1).cornerRadius(12).padAngle(0.014);
          const stages = DATA.loop.stages;

          g.append("circle")
            .attr("r", rr1 + 18)
            .attr("fill", "none")
            .attr("stroke", "rgba(233,237,255,0.10)")
            .attr("stroke-dasharray", "4,10");

          const pathSel = g.selectAll("path.stage").data(stages, (d) => d.name);
          pathSel
            .join("path")
            .attr("class", "stage")
            .attr("fill", (d) => d.color)
            .attr("fill-opacity", 0.78)
            .attr("stroke", "rgba(233,237,255,0.16)")
            .attr("stroke-width", 1)
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${d.name}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt(d.beforeHrs)}h</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt(d.afterHrs)}h</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide())
            .attr("d", arc({ startAngle: 0, endAngle: 0 }));

          const labelSel = g.selectAll("text.stage-label").data(stages, (d) => d.name);
          labelSel
            .join("text")
            .attr("class", "stage-label")
            .attr("fill", "rgba(8,10,16,0.88)")
            .attr("font-size", 12)
            .attr("font-weight", 780)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle");

          gText
            .append("text")
            .attr("class", "big")
            .attr("text-anchor", "middle")
            .attr("y", -8)
            .attr("fill", theme.ink)
            .attr("font-size", 28)
            .attr("font-weight", 820)
            .text("—");

          gText
            .append("text")
            .attr("class", "small")
            .attr("text-anchor", "middle")
            .attr("y", 18)
            .attr("fill", theme.muted)
            .attr("font-size", 12)
            .text("End-to-end iteration cycle");

          svg
            .append("text")
            .attr("x", 14)
            .attr("y", 20)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("The loop gets shorter as AI collapses waiting + iteration steps.");
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const stages = DATA.loop.stages.map((d) => ({
            ...d,
            hrs: lerp(d.beforeHrs, d.afterHrs, ease),
          }));
          const total = d3.sum(stages, (d) => d.hrs);

          const rr0 = Math.min(w, h) * 0.18;
          const rr1 = Math.min(w, h) * 0.40;
          const arc = d3.arc().innerRadius(rr0).outerRadius(rr1).cornerRadius(12).padAngle(0.014);
          const a0 = -Math.PI / 2;
          let cur = a0;
          const spans = stages.map((d) => {
            const span = (d.hrs / total) * Math.PI * 2;
            const out = { ...d, startAngle: cur, endAngle: cur + span, midAngle: cur + span / 2 };
            cur += span;
            return out;
          });

          g.selectAll("path.stage").data(spans, (d) => d.name).attr("d", (d) => arc(d));
          g.selectAll("text.stage-label")
            .data(spans, (d) => d.name)
            .attr("x", (d) => Math.cos(d.midAngle) * (rr0 + (rr1 - rr0) * 0.62))
            .attr("y", (d) => Math.sin(d.midAngle) * (rr0 + (rr1 - rr0) * 0.62))
            .text((d) => d.name);

          const big = gText.select("text.big");
          big.text(`${fmt(total)}h`);
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 5: Autonomy dashboard ----
      const autonomyChart = (() => {
        const el = $("#chart-autonomy");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 18, r: 18, t: 18, b: 18 };
        let w = 0;
        let h = 0;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          g.append("text")
            .attr("x", pad.l)
            .attr("y", 18)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text(DATA.autonomy.note);

          const rowH = (h - pad.t - pad.b - 24) / 3;
          const rows = DATA.autonomy.metrics.map((m, i) => ({ ...m, i, y: pad.t + 30 + i * rowH }));
          const trackW = w - pad.l - pad.r - 150;

          const rowSel = g.selectAll("g.row").data(rows, (d) => d.key);
          const rowEnter = rowSel
            .join((enter) => enter.append("g").attr("class", "row"))
            .attr("transform", (d) => `translate(${pad.l},${d.y})`);

          rowEnter
            .append("text")
            .attr("class", "k")
            .attr("x", 0)
            .attr("y", 0)
            .attr("fill", theme.ink)
            .attr("font-size", 13)
            .attr("font-weight", 750)
            .attr("dominant-baseline", "hanging")
            .text((d) => d.key);

          rowEnter
            .append("text")
            .attr("class", "u")
            .attr("x", 0)
            .attr("y", 18)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .attr("dominant-baseline", "hanging")
            .text((d) => (d.unit ? d.unit : d.direction === "down" ? "lower is better" : "higher is better"));

          const x = (d) => d3.scaleLinear().domain(d.domain).range([120, 120 + trackW]);

          rowEnter
            .append("rect")
            .attr("class", "track")
            .attr("x", 120)
            .attr("y", 8)
            .attr("width", trackW)
            .attr("height", 18)
            .attr("rx", 10)
            .attr("fill", "rgba(0,0,0,0.18)")
            .attr("stroke", "rgba(233,237,255,0.16)");

          rowEnter
            .append("rect")
            .attr("class", "fill")
            .attr("x", 120)
            .attr("y", 8)
            .attr("height", 18)
            .attr("rx", 10)
            .attr("fill", (d) => d.color)
            .attr("fill-opacity", 0.66);

          rowEnter
            .append("circle")
            .attr("class", "knob")
            .attr("cy", 17)
            .attr("r", 9)
            .attr("fill", "rgba(6,10,18,0.85)")
            .attr("stroke", "rgba(233,237,255,0.24)")
            .attr("stroke-width", 1.2);

          rowEnter
            .append("text")
            .attr("class", "val")
            .attr("x", 120 + trackW + 14)
            .attr("y", 8)
            .attr("fill", theme.ink)
            .attr("font-size", 22)
            .attr("font-weight", 820)
            .attr("dominant-baseline", "hanging");

          rowEnter
            .append("text")
            .attr("class", "delta")
            .attr("x", 120 + trackW + 14)
            .attr("y", 34)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .attr("dominant-baseline", "hanging");

          // Interaction area
          rowEnter
            .append("rect")
            .attr("class", "hit")
            .attr("x", 110)
            .attr("y", 0)
            .attr("width", trackW + 170)
            .attr("height", 44)
            .attr("fill", "transparent")
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              const delta = d.after - d.before;
              tooltip.show(
                `<div class="t-title">${d.key}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt(d.before)}</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt(d.after)}</span></div>
                 <div class="t-row">Change: <span class="kbdish">${delta > 0 ? "+" : ""}${fmt(delta)}</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          // Store scale per row.
          rows.forEach((r) => (r._x = x(r)));
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const rows = DATA.autonomy.metrics.map((m) => ({
            ...m,
            v: lerp(m.before, m.after, ease),
          }));
          const rowH = (h - pad.t - pad.b - 24) / 3;
          const rowsWithY = rows.map((m, i) => ({ ...m, i, y: pad.t + 30 + i * rowH }));
          const trackW = w - pad.l - pad.r - 150;

          const xScale = (d) => d3.scaleLinear().domain(d.domain).range([120, 120 + trackW]);
          const rowSel = g.selectAll("g.row").data(rowsWithY, (d) => d.key);

          rowSel.each(function (d) {
            const gx = d3.select(this);
            const x = xScale(d);
            const fillW = Math.max(0, x(d.v) - 120);
            gx.select("rect.fill").attr("width", fillW);
            gx.select("circle.knob").attr("cx", x(d.v));
            gx.select("text.val").text(`${fmt(d.v)}${d.key === "Complexity" ? "" : ""}`);
            const delta = d.after - d.before;
            const up = delta >= 0 ? "↑" : "↓";
            const better = d.direction === "down" ? (delta < 0 ? "better" : "worse") : delta > 0 ? "better" : "worse";
            gx.select("text.delta").text(`${up} ${fmt(Math.abs(delta))} (${better})`);
          });
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 6: Learning distribution (morphing histogram) ----
      const learningChart = (() => {
        const el = $("#chart-learning");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 44, r: 14, t: 18, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;
        let bins = null;

        const buildBins = (values) => {
          const histogram = d3
            .histogram()
            .domain([0, 28])
            .thresholds(d3.range(0, 29, 2));
          return histogram(values);
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          x = d3.scaleLinear().domain([0, 28]).range([pad.l, w - pad.r]);
          const beforeBins = buildBins(DATA.learning.beforeDays);
          const afterBins = buildBins(DATA.learning.afterDays);
          bins = { beforeBins, afterBins };
          const maxY = Math.max(d3.max(beforeBins, (d) => d.length) ?? 0, d3.max(afterBins, (d) => d.length) ?? 0);
          y = d3.scaleLinear().domain([0, maxY * 1.12]).range([h - pad.b, pad.t]);

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(7).tickSizeOuter(0).tickFormat((d) => `${d}d`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("g")
            .attr("transform", `translate(${pad.l},0)`)
            .call(d3.axisLeft(y).ticks(4).tickSizeOuter(0))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text")
            .attr("x", (pad.l + (w - pad.r)) / 2)
            .attr("y", h - 10)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Days to ship a first unfamiliar-domain change  →");

          const barW = (x(2) - x(0)) - 6;

          const layers = [
            { key: "before", fill: theme.b, alpha: 0.35, label: "Before" },
            { key: "after", fill: theme.a, alpha: 0.35, label: "After" },
          ];

          const legend = svg.append("g").attr("transform", `translate(${14},${16})`);
          legend
            .selectAll("g.item")
            .data(layers)
            .join((enter) => {
              const gg = enter.append("g").attr("class", "item");
              gg.append("circle").attr("r", 6).attr("cy", 0);
              gg.append("text").attr("x", 12).attr("y", 0).attr("dominant-baseline", "middle").attr("font-size", 11);
              return gg;
            })
            .attr("transform", (_, i) => `translate(0,${i * 16})`)
            .each(function (d) {
              const sel = d3.select(this);
              sel.select("circle").attr("fill", d.fill).attr("fill-opacity", 0.7);
              sel.select("text").attr("fill", theme.muted).text(d.label);
            });

          const binX = (b) => x(b.x0 ?? 0) + 3;
          const bar = g
            .append("g")
            .selectAll("rect")
            .data(beforeBins)
            .join("rect")
            .attr("x", (d) => binX(d))
            .attr("y", y(0))
            .attr("width", barW)
            .attr("height", 0)
            .attr("rx", 8)
            .attr("fill", theme.b)
            .attr("fill-opacity", 0.65)
            .attr("stroke", "rgba(233,237,255,0.14)")
            .on("mousemove", (event, d) => {
              const i = beforeBins.indexOf(d);
              const b = beforeBins[i];
              const a = afterBins[i];
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${fmt0(b.x0)}–${fmt0(b.x1)} days</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt0(b.length)}</span> cases</div>
                 <div class="t-row">After: <span class="kbdish">${fmt0(a.length)}</span> cases</div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          // Overlay ghost bars for "after".
          g.append("g")
            .selectAll("rect.ghost")
            .data(afterBins)
            .join("rect")
            .attr("class", "ghost")
            .attr("x", (d) => binX(d))
            .attr("y", y(0))
            .attr("width", barW)
            .attr("height", 0)
            .attr("rx", 8)
            .attr("fill", theme.a)
            .attr("fill-opacity", 0.55)
            .attr("stroke", "rgba(233,237,255,0.12)");

          svg
            .append("text")
            .attr("x", 14)
            .attr("y", h - 12)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("The “after” mass shifts left (faster learning + iteration).");
        };

        const update = (t) => {
          if (!bins) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const { beforeBins, afterBins } = bins;
          const toHeight = (count) => Math.max(0, y(0) - y(count));

          const interp = beforeBins.map((b, i) => ({
            x0: b.x0,
            x1: b.x1,
            count: lerp(b.length, afterBins[i]?.length ?? 0, ease),
            before: b.length,
            after: afterBins[i]?.length ?? 0,
          }));

          g.selectAll("rect:not(.ghost)")
            .data(interp)
            .attr("y", (d) => y(d.count))
            .attr("height", (d) => toHeight(d.count))
            .attr("fill-opacity", lerp(0.70, 0.25, ease));

          g.selectAll("rect.ghost")
            .data(afterBins)
            .attr("y", (d, i) => y(lerp(beforeBins[i].length, d.length, ease)))
            .attr("height", (d, i) => toHeight(lerp(beforeBins[i].length, d.length, ease)))
            .attr("fill-opacity", lerp(0.20, 0.60, ease));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 7: Work iceberg (xenographic) ----
      const icebergChart = (() => {
        const el = $("#chart-iceberg");
        const svg = makeSvg(el);
        const g = svg.append("g");
        let w = 0;
        let h = 0;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const waterY = h * 0.52;
          const sky = svg.append("defs");
          const grad = sky
            .append("linearGradient")
            .attr("id", "water-grad")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "0%")
            .attr("y2", "100%");
          grad.append("stop").attr("offset", "0%").attr("stop-color", "rgba(122,167,255,0.10)");
          grad.append("stop").attr("offset", "100%").attr("stop-color", "rgba(0,0,0,0.25)");

          g.append("rect").attr("x", 0).attr("y", 0).attr("width", w).attr("height", waterY).attr("fill", "rgba(255,255,255,0.02)");
          g.append("rect").attr("x", 0).attr("y", waterY).attr("width", w).attr("height", h - waterY).attr("fill", "url(#water-grad)");

          g.append("path")
            .attr("d", `M0,${waterY} C${w * 0.18},${waterY - 8} ${w * 0.32},${waterY + 9} ${w * 0.5},${waterY}
                     C${w * 0.68},${waterY - 9} ${w * 0.82},${waterY + 8} ${w},${waterY} L${w},${waterY + 10} L0,${waterY + 10} Z`)
            .attr("fill", "rgba(233,237,255,0.06)")
            .attr("stroke", "rgba(233,237,255,0.14)");

          g.append("text")
            .attr("x", 14)
            .attr("y", 22)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("The “priority line”: work that makes it above water gets done first.");

          const boxW = Math.min(300, w * 0.66);
          const cx = w * 0.56;
          const icebergTop = waterY - 170;
          const icebergBottom = h - 26;
          const categories = DATA.iceberg.categories;

          const stack = d3.stack().keys(["before", "after"]);
          // We'll render blocks ourselves, interpolating.

          const container = g.append("g").attr("transform", `translate(${cx - boxW / 2},${icebergTop})`);
          container.append("rect").attr("x", 0).attr("y", 0).attr("width", boxW).attr("height", icebergBottom - icebergTop).attr("rx", 18).attr("fill", "rgba(0,0,0,0.12)").attr("stroke", "rgba(233,237,255,0.12)");

          const blockPad = 8;
          const innerW = boxW - blockPad * 2;
          const innerH = icebergBottom - icebergTop - blockPad * 2;
          const baseY = blockPad;

          const blocks = container.append("g").attr("transform", `translate(${blockPad},${baseY})`);
          const labels = container.append("g").attr("transform", `translate(${boxW + 14},${baseY})`);

          const mk = (d) => d.name;
          const blockSel = blocks.selectAll("rect.block").data(categories, mk);
          blockSel
            .join((enter) =>
              enter
                .append("rect")
                .attr("class", "block")
                .attr("rx", 14)
                .attr("fill", (d) => d.color)
                .attr("fill-opacity", 0.78)
                .attr("stroke", "rgba(233,237,255,0.12)")
                .on("mousemove", (event, d) => {
                  const pos = pointer(event, el);
                  tooltip.show(
                    `<div class="t-title">${d.name}</div>
                     <div class="t-row">Before: <span class="kbdish">${fmt0(d.before * 100)}%</span></div>
                     <div class="t-row">After: <span class="kbdish">${fmt0(d.after * 100)}%</span></div>`,
                    pos.x,
                    pos.y
                  );
                })
                .on("mouseleave", () => tooltip.hide())
            )
            .attr("x", 0)
            .attr("width", innerW);

          const labelSel = labels.selectAll("text.l").data(categories, mk);
          labelSel
            .join((enter) =>
              enter
                .append("text")
                .attr("class", "l")
                .attr("fill", theme.ink)
                .attr("font-size", 12)
                .attr("font-weight", 750)
                .attr("dominant-baseline", "middle")
            )
            .text((d) => d.name);

          // Store geometry + waterline marker.
          el._iceberg = { waterY, cx, boxW, icebergTop, icebergBottom, innerH, innerW, blockPad, categories, blocks, labels, container };

          // Waterline marker relative to container
          const waterInContainer = waterY - icebergTop - blockPad;
          blocks.append("line")
            .attr("class", "waterline")
            .attr("x1", -8)
            .attr("x2", innerW + 8)
            .attr("y1", waterInContainer)
            .attr("y2", waterInContainer)
            .attr("stroke", "rgba(233,237,255,0.22)")
            .attr("stroke-dasharray", "6,8");
          blocks.append("text")
            .attr("class", "waterline-label")
            .attr("x", innerW - 8)
            .attr("y", waterInContainer - 10)
            .attr("text-anchor", "end")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("priority line");
        };

        const update = (t) => {
          const geo = el._iceberg;
          if (!geo) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const { innerH, innerW, waterY, icebergTop, blockPad, categories, blocks, labels } = geo;
          const waterInContainer = waterY - icebergTop - blockPad;

          const shares = categories.map((d) => ({ ...d, share: lerp(d.before, d.after, ease) }));
          // Stack top-to-bottom
          let y0 = 0;
          const laid = shares.map((d) => {
            const h = innerH * d.share;
            const out = { ...d, y: y0, h };
            y0 += h + 6;
            return out;
          });

          const totalHeight = d3.sum(laid, (d) => d.h) + (laid.length - 1) * 6;
          const shift = (innerH - totalHeight) / 2;

          const blockSel = blocks.selectAll("rect.block").data(laid, (d) => d.name);
          blockSel.attr("y", (d) => d.y + shift).attr("height", (d) => Math.max(16, d.h));

          // Make “neglected” categories float upward above waterline more in after.
          const neglected = new Set(["Docs & tests", "Tools & dashboards", "Papercuts"]);
          blockSel.attr("transform", (d) => {
            const center = d.y + shift + d.h / 2;
            if (!neglected.has(d.name)) return "translate(0,0)";
            const distBelow = Math.max(0, center - waterInContainer);
            const lift = lerp(0, Math.min(26, distBelow * 0.18), ease);
            return `translate(0,${-lift})`;
          });

          const labelSel = labels.selectAll("text.l").data(laid, (d) => d.name);
          labelSel.attr("y", (d) => d.y + shift + d.h / 2);
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 8: Papercut backlog burn-down ----
      const burndownChart = (() => {
        const el = $("#chart-burndown");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 44, r: 18, t: 18, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const maxOpen = 250;
          x = d3.scaleLinear().domain([0, 12]).range([pad.l, w - pad.r]);
          y = d3.scaleLinear().domain([0, maxOpen]).range([h - pad.b, pad.t]);

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(6).tickSizeOuter(0).tickFormat((d) => `wk ${d}`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("g")
            .attr("transform", `translate(${pad.l},0)`)
            .call(d3.axisLeft(y).ticks(4).tickSizeOuter(0))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text")
            .attr("x", (pad.l + (w - pad.r)) / 2)
            .attr("y", h - 10)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Weeks since starting a “papercut sweep”  →");

          const line = d3
            .line()
            .x((d) => x(d.week))
            .y((d) => y(d.open))
            .curve(d3.curveMonotoneX);

          const area = d3
            .area()
            .x((d) => x(d.week))
            .y0(y(0))
            .y1((d) => y(d.open))
            .curve(d3.curveMonotoneX);

          const before = DATA.burndown.papercutsBefore;
          const after = DATA.burndown.papercutsAfter;

          g.append("path").attr("class", "area-before").attr("d", area(before)).attr("fill", theme.b).attr("fill-opacity", 0.18);
          g.append("path").attr("class", "area-after").attr("d", area(after)).attr("fill", theme.danger).attr("fill-opacity", 0.10);

          g.append("path")
            .attr("class", "line-before")
            .attr("d", line(before))
            .attr("fill", "none")
            .attr("stroke", theme.b)
            .attr("stroke-opacity", 0.78)
            .attr("stroke-width", 3)
            .attr("stroke-linecap", "round");

          g.append("path")
            .attr("class", "line-after")
            .attr("d", line(after))
            .attr("fill", "none")
            .attr("stroke", theme.danger)
            .attr("stroke-opacity", 0.78)
            .attr("stroke-width", 3)
            .attr("stroke-linecap", "round");

          const cursor = g.append("g").attr("class", "cursor").attr("opacity", 0);
          cursor.append("line").attr("y1", pad.t).attr("y2", h - pad.b).attr("stroke", "rgba(233,237,255,0.16)").attr("stroke-dasharray", "4,8");
          cursor.append("circle").attr("r", 6).attr("fill", theme.danger).attr("stroke", "rgba(233,237,255,0.18)");
          cursor.append("circle").attr("r", 6).attr("fill", theme.b).attr("stroke", "rgba(233,237,255,0.18)").attr("transform", "translate(0,0)");

          g.append("text")
            .attr("x", pad.l)
            .attr("y", 18)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("After AI: “activation energy” drops, papercuts stop getting perpetually deprioritized.");

          // Interaction
          svg
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", w)
            .attr("height", h)
            .attr("fill", "transparent")
            .on("mousemove", (event) => {
              const [px] = d3.pointer(event, svg.node());
              const week = Math.round(clamp01((px - pad.l) / (w - pad.l - pad.r)) * 12);
              const b = before[week];
              const a = after[week];
              cursor.attr("opacity", 1);
              cursor.select("line").attr("x1", x(week)).attr("x2", x(week));
              cursor.selectAll("circle").data([0, 1]).attr("cx", x(week)).attr("cy", (d) => (d === 0 ? y(a.open) : y(b.open))).attr("fill", (d) => (d === 0 ? theme.danger : theme.b));

              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">Week ${week}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt0(b.open)}</span> open</div>
                 <div class="t-row">After: <span class="kbdish">${fmt0(a.open)}</span> open</div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => {
              g.select("g.cursor").attr("opacity", 0);
              tooltip.hide();
            });
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          g.select(".line-before").attr("stroke-opacity", lerp(0.82, 0.18, ease));
          g.select(".area-before").attr("fill-opacity", lerp(0.20, 0.06, ease));
          g.select(".line-after").attr("stroke-opacity", lerp(0.12, 0.86, ease));
          g.select(".area-after").attr("fill-opacity", lerp(0.05, 0.16, ease));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 9: Work portfolio shift (stacked area) ----
      const portfolioChart = (() => {
        const el = $("#chart-portfolio");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 44, r: 16, t: 18, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const data = DATA.portfolio.map((d) => ({
            month: d.m,
            core: d.core,
            accel: d.accel,
            novel: d.novel,
          }));

          x = d3.scaleLinear().domain([0, 11]).range([pad.l, w - pad.r]);
          y = d3.scaleLinear().domain([0, 1]).range([h - pad.b, pad.t]);

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(6).tickSizeOuter(0).tickFormat((d) => `m${d}`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("g")
            .attr("transform", `translate(${pad.l},0)`)
            .call(d3.axisLeft(y).ticks(4).tickSizeOuter(0).tickFormat(d3.format(".0%")))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text")
            .attr("x", (pad.l + (w - pad.r)) / 2)
            .attr("y", h - 10)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Months of adoption → (synthetic year-over-year shift)");

          const keys = ["core", "accel", "novel"];
          const color = d3.scaleOrdinal(keys, [theme.b, theme.a, theme.c]);
          const stack = d3.stack().keys(keys);
          const series = stack(data);

          const area = d3
            .area()
            .x((d, i) => x(data[i].month))
            .y0((d) => y(d[0]))
            .y1((d) => y(d[1]))
            .curve(d3.curveMonotoneX);

          g.append("g")
            .selectAll("path.layer")
            .data(series, (d) => d.key)
            .join("path")
            .attr("class", "layer")
            .attr("fill", (d) => color(d.key))
            .attr("fill-opacity", 0.38)
            .attr("stroke", "rgba(233,237,255,0.12)")
            .attr("stroke-width", 1)
            .attr("d", area);

          // Legend
          const legend = svg.append("g").attr("transform", `translate(${14},${16})`);
          const items = [
            { key: "core", label: "Core work (would happen anyway)" },
            { key: "accel", label: "Accelerated core (more throughput)" },
            { key: "novel", label: "New / otherwise-not-done" },
          ];
          legend
            .selectAll("g.item")
            .data(items)
            .join((enter) => {
              const gg = enter.append("g").attr("class", "item");
              gg.append("rect").attr("width", 12).attr("height", 12).attr("rx", 4).attr("y", -6);
              gg.append("text").attr("x", 16).attr("y", 0).attr("dominant-baseline", "middle").attr("font-size", 11);
              return gg;
            })
            .attr("transform", (_, i) => `translate(0,${i * 16})`)
            .each(function (d) {
              const sel = d3.select(this);
              sel.select("rect").attr("fill", color(d.key)).attr("fill-opacity", 0.75);
              sel.select("text").attr("fill", theme.muted).text(d.label);
            });

          // Scrub tooltip
          const overlay = svg.append("rect").attr("x", 0).attr("y", 0).attr("width", w).attr("height", h).attr("fill", "transparent");
          overlay.on("mousemove", (event) => {
            const [px] = d3.pointer(event, svg.node());
            const m = Math.round(clamp01((px - pad.l) / (w - pad.l - pad.r)) * 11);
            const d = data[m];
            const pos = pointer(event, el);
            tooltip.show(
              `<div class="t-title">Month ${m}</div>
               <div class="t-row">Core: <span class="kbdish">${fmt0(d.core * 100)}%</span></div>
               <div class="t-row">Accelerated core: <span class="kbdish">${fmt0(d.accel * 100)}%</span></div>
               <div class="t-row">New work: <span class="kbdish">${fmt0(d.novel * 100)}%</span></div>`,
              pos.x,
              pos.y
            );
          });
          overlay.on("mouseleave", () => tooltip.hide());

          svg
            .append("text")
            .attr("x", 14)
            .attr("y", h - 12)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Note: “new work” rises because 27% of Claude-assisted work would not be done otherwise.");
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          // Reveal from left to right using a clipPath.
          const id = "clip-portfolio";
          const defs = svg.selectAll("defs").data([0]).join("defs");
          defs
            .selectAll(`#${id}`)
            .data([0])
            .join("clipPath")
            .attr("id", id)
            .selectAll("rect")
            .data([0])
            .join("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", w * lerp(0.22, 1, ease))
            .attr("height", h);
          g.selectAll("path.layer").attr("clip-path", `url(#${id})`);
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 10: Cross-stack contribution matrix (heatmap) ----
      const matrixChart = (() => {
        const el = $("#chart-matrix");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 92, r: 16, t: 26, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          x = d3.scaleBand().domain(DATA.matrix.domains).range([pad.l, w - pad.r]).paddingInner(0.10).paddingOuter(0.05);
          y = d3.scaleBand().domain(DATA.matrix.roles).range([pad.t, h - pad.b]).paddingInner(0.14).paddingOuter(0.06);

          const cellW = x.bandwidth();
          const cellH = y.bandwidth();
          const color = d3
            .scaleSequential(d3.interpolateRgbBasis(["rgba(255,255,255,0.06)", "rgba(122,167,255,0.55)", "rgba(157,255,203,0.86)"]))
            .domain([0, 85]);

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Heatmap morph: as AI lowers friction, cross-stack contribution rises.");

          g.append("g")
            .selectAll("text")
            .data(DATA.matrix.domains)
            .join("text")
            .attr("x", (d) => x(d) + cellW / 2)
            .attr("y", pad.t - 8)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text((d) => d);

          g.append("g")
            .selectAll("text")
            .data(DATA.matrix.roles)
            .join("text")
            .attr("x", pad.l - 10)
            .attr("y", (d) => y(d) + cellH / 2)
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 12)
            .attr("font-weight", 650)
            .text((d) => d);

          const cells = [];
          for (const r of DATA.matrix.roles) for (const d of DATA.matrix.domains) cells.push({ r, d });

          g.append("g")
            .selectAll("rect")
            .data(cells, (d) => `${d.r}|${d.d}`)
            .join("rect")
            .attr("x", (d) => x(d.d))
            .attr("y", (d) => y(d.r))
            .attr("width", cellW)
            .attr("height", cellH)
            .attr("rx", 12)
            .attr("fill", "rgba(255,255,255,0.06)")
            .attr("stroke", "rgba(233,237,255,0.14)")
            .on("mousemove", (event, d) => {
              const b = DATA.matrix.before[d.r][d.d];
              const a = DATA.matrix.after[d.r][d.d];
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${d.r} → ${d.d}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt0(b)}%</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt0(a)}%</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).text("Brighter = more engineers shipping there.");
          el._matrixColor = color;
        };

        const update = (t) => {
          if (!x || !y) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const color = el._matrixColor;
          g.selectAll("rect").attr("fill", (d) => color(lerp(DATA.matrix.before[d.r][d.d], DATA.matrix.after[d.r][d.d], ease)));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 11: Breadth fireflies (animated swarm) ----
      const firefliesChart = (() => {
        const el = $("#chart-fireflies");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 30, r: 18, t: 20, b: 36 };
        let w = 0;
        let h = 0;
        let x = null;
        let points = null;
        let raf = /** @type {number|null} */ (null);
        let start = 0;

        const buildPoints = () => {
          const seeded = d3.randomLcg(0.19);
          const jitterX = d3.randomNormal.source(seeded)(0, 0.10);
          const jitterY = d3.randomNormal.source(seeded)(0, 0.55);
          return DATA.breadth.map((d) => ({
            ...d,
            bx: d.before + jitterX(),
            ax: d.after + jitterX(),
            by: jitterY(),
            ay: jitterY(),
            phase: seeded() * Math.PI * 2,
            glow: 0.7 + seeded() * 0.9,
          }));
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          x = d3.scaleLinear().domain([1, 6]).range([pad.l, w - pad.r]);
          points = buildPoints();

          const defs = svg.selectAll("defs").data([0]).join("defs");
          const filter = defs.selectAll("#glow-fireflies").data([0]).join("filter").attr("id", "glow-fireflies");
          filter.selectAll("*").remove();
          filter.append("feGaussianBlur").attr("stdDeviation", "3.2").attr("result", "coloredBlur");
          const feMerge = filter.append("feMerge");
          feMerge.append("feMergeNode").attr("in", "coloredBlur");
          feMerge.append("feMergeNode").attr("in", "SourceGraphic");

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(6).tickSizeOuter(0).tickFormat((d) => `${d}`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Each dot is one engineer (n=132). X = domains touched/month.");

          const color = (role) => DATA.palette.roleColor(role);
          const midY = pad.t + (h - pad.b - pad.t) * 0.55;

          g.append("g")
            .attr("filter", "url(#glow-fireflies)")
            .selectAll("circle")
            .data(points, (d) => d.i)
            .join("circle")
            .attr("r", 4.2)
            .attr("fill", (d) => color(d.role))
            .attr("fill-opacity", 0.58)
            .attr("stroke", "rgba(233,237,255,0.18)")
            .attr("cx", (d) => x(d.before))
            .attr("cy", () => midY)
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">Engineer #${d.i + 1}</div>
                 <div class="t-row">Home role: <span class="kbdish">${d.role}</span></div>
                 <div class="t-row">Before breadth: <span class="kbdish">${d.before}</span></div>
                 <div class="t-row">After breadth: <span class="kbdish">${d.after}</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).text("Fireflies = breadth distribution shifting right.");

          if (!prefersReducedMotion) {
            start = performance.now();
            if (raf) cancelAnimationFrame(raf);
            const tick = (now) => {
              const tt = (now - start) / 1000;
              g.selectAll("circle")
                .attr("r", (d) => 3.7 + Math.sin(tt * 2.2 + d.phase) * 0.9 * d.glow)
                .attr("fill-opacity", (d) => 0.40 + (Math.sin(tt * 1.6 + d.phase) * 0.14 + 0.20) * d.glow);
              raf = requestAnimationFrame(tick);
            };
            raf = requestAnimationFrame(tick);
          }
        };

        const update = (t) => {
          if (!x || !points) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const yBand = d3.scaleBand().domain(d3.range(1, 7).map(String)).range([pad.t + 20, h - pad.b - 18]).padding(0.08);
          g.selectAll("circle")
            .attr("cx", (d) => x(lerp(d.bx, d.ax, ease)))
            .attr("cy", (d) => {
              const b = yBand(String(Math.round(lerp(d.before, d.after, ease)))) ?? (pad.t + (h - pad.b - pad.t) / 2);
              const drift = Math.sin(performance.now() / 1000 + d.phase) * 12;
              return b + yBand.bandwidth() / 2 + drift * 0.12 + lerp(d.by, d.ay, ease) * 10;
            });
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 12: Claude task-mix compass (radial pie morph) ----
      const compassChart = (() => {
        const el = $("#chart-compass");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const gLbl = svg.append("g");
        let w = 0;
        let h = 0;
        let cx = 0;
        let cy = 0;
        let r0 = 0;
        let r1 = 0;
        let arc = null;
        let pie = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();
          gLbl.selectAll("*").remove();

          cx = w * 0.52;
          cy = h * 0.54;
          r0 = Math.min(w, h) * 0.18;
          r1 = Math.min(w, h) * 0.40;
          g.attr("transform", `translate(${cx},${cy})`);
          gLbl.attr("transform", `translate(${cx},${cy})`);

          arc = d3.arc().innerRadius(r0).outerRadius(r1).cornerRadius(10).padAngle(0.01);
          pie = d3.pie().sort(null).value((d) => d.v);

          const keys = DATA.taskMix.keys;
          const col = (k) => DATA.palette.taskColor(k) ?? theme.ink;

          g.append("circle").attr("r", r1 + 18).attr("fill", "none").attr("stroke", "rgba(233,237,255,0.10)").attr("stroke-dasharray", "4,10");

          const init = keys.map((k) => ({ k, v: DATA.taskMix.before[k] }));
          g.append("g")
            .selectAll("path")
            .data(pie(init), (d) => d.data.k)
            .join("path")
            .attr("fill", (d) => col(d.data.k))
            .attr("fill-opacity", 0.70)
            .attr("stroke", "rgba(233,237,255,0.16)")
            .attr("d", arc)
            .on("mousemove", (event, d) => {
              const k = d.data.k;
              const b = DATA.taskMix.before[k];
              const a = DATA.taskMix.after[k];
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${k}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt(b)}%</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt(a)}%</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          svg.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Morph Feb → Aug 2025: usage shifts toward complex tasks.");

          gLbl.append("text").attr("text-anchor", "middle").attr("y", -10).attr("fill", theme.ink).attr("font-size", 26).attr("font-weight", 850).text("Task mix");
          gLbl.append("text").attr("text-anchor", "middle").attr("y", 14).attr("fill", theme.muted).attr("font-size", 12).text("Claude Code usage distribution");
        };

        const update = (t) => {
          if (!arc || !pie) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const keys = DATA.taskMix.keys;
          const vals = keys.map((k) => ({ k, v: lerp(DATA.taskMix.before[k], DATA.taskMix.after[k], ease) }));
          const arcs = pie(vals);
          g.selectAll("path").data(arcs, (d) => d.data.k).attr("d", arc);
          const pulse = 0.75 + Math.sin(performance.now() / 600) * 0.08;
          g.selectAll("path").attr("fill-opacity", (d) => (["New features", "Design/planning"].includes(d.data.k) ? lerp(0.62, 0.88, ease) * pulse : 0.62));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 13: “A million horses” branching (xenographic) ----
      const horsesChart = (() => {
        const el = $("#chart-horses");
        const svg = makeSvg(el);
        const g = svg.append("g");
        let w = 0;
        let h = 0;
        /** @type {{path: SVGPathElement, len: number, idx: number, dot: SVGCircleElement}[]} */
        let branches = [];
        let raf = /** @type {number|null} */ (null);
        let start = 0;

        const build = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();
          branches = [];

          const seeded = d3.randomLcg(0.77);
          const root = { x: 40, y: h * 0.55 };
          const trunk = { x: w * 0.34, y: h * 0.55 };
          const leaves = d3.range(10).map((i) => ({
            i,
            x: w - 44,
            y: h * 0.18 + (i / 9) * (h * 0.68) + (seeded() - 0.5) * 18,
          }));

          const defs = svg.selectAll("defs").data([0]).join("defs");
          const grad = defs.selectAll("#horse-grad").data([0]).join("linearGradient").attr("id", "horse-grad");
          grad.attr("x1", "0%").attr("y1", "0%").attr("x2", "100%").attr("y2", "0%");
          grad.selectAll("*").remove();
          grad.append("stop").attr("offset", "0%").attr("stop-color", "rgba(122,167,255,0.24)");
          grad.append("stop").attr("offset", "60%").attr("stop-color", "rgba(157,255,203,0.24)");
          grad.append("stop").attr("offset", "100%").attr("stop-color", "rgba(255,111,216,0.22)");

          g.append("text")
            .attr("x", 14)
            .attr("y", 18)
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Parallel exploration: more “branches” mean tighter idea→test feedback loops.");

          const mkPath = (pts) => d3.line().x((d) => d.x).y((d) => d.y).curve(d3.curveBumpX)(pts);

          g.append("path")
            .attr("d", mkPath([root, trunk]))
            .attr("fill", "none")
            .attr("stroke", "rgba(233,237,255,0.16)")
            .attr("stroke-width", 6)
            .attr("stroke-linecap", "round");

          g.append("text").attr("x", root.x).attr("y", root.y - 18).attr("fill", theme.ink).attr("font-size", 12).attr("font-weight", 750).text("Problem");
          g.append("text").attr("x", trunk.x).attr("y", trunk.y - 18).attr("fill", theme.ink).attr("font-size", 12).attr("font-weight", 750).text("Prompt");
          g.append("text").attr("x", w - 44).attr("y", h * 0.12).attr("text-anchor", "end").attr("fill", theme.ink).attr("font-size", 12).attr("font-weight", 750).text("Candidate solutions");

          const pathGroup = g.append("g");
          const dotGroup = g.append("g");
          const leafGroup = g.append("g");

          leaves.forEach((leaf) => {
            const mid1 = { x: lerp(trunk.x, w * 0.52, 0.5), y: lerp(trunk.y, leaf.y, 0.22) };
            const mid2 = { x: lerp(w * 0.52, w * 0.72, 0.7), y: lerp(trunk.y, leaf.y, 0.62) };
            const d = mkPath([trunk, mid1, mid2, leaf]);
            const p = pathGroup
              .append("path")
              .attr("d", d)
              .attr("fill", "none")
              .attr("stroke", "url(#horse-grad)")
              .attr("stroke-width", 3.2)
              .attr("stroke-opacity", 0.70)
              .attr("stroke-linecap", "round")
              .node();
            const dot = dotGroup
              .append("circle")
              .attr("r", 4.8)
              .attr("fill", leaf.i % 2 ? theme.c : theme.a)
              .attr("fill-opacity", 0.80)
              .attr("stroke", "rgba(233,237,255,0.20)")
              .node();

            leafGroup.append("circle").attr("cx", leaf.x).attr("cy", leaf.y).attr("r", 4).attr("fill", "rgba(233,237,255,0.22)");
            branches.push({ path: p, len: p.getTotalLength(), idx: leaf.i, dot });
          });

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).attr("class", "branch-count").text("—");

          if (!prefersReducedMotion) {
            start = performance.now();
            if (raf) cancelAnimationFrame(raf);
            const tick = (now) => {
              const tt = (now - start) / 1000;
              const tGlobal = d3.easeCubicInOut(clamp01(state.t));
              const active = Math.max(1, Math.round(lerp(1, 10, tGlobal)));
              const speed = lerp(0.16, 0.66, tGlobal);
              branches.forEach((b) => {
                const visible = b.idx < active;
                b.path.style.opacity = visible ? String(lerp(0.12, 0.90, tGlobal)) : "0.06";
                b.dot.style.opacity = visible ? "0.95" : "0.10";
                const dist = ((tt * speed * b.len) + b.idx * 29) % b.len;
                const pt = b.path.getPointAtLength(dist);
                b.dot.setAttribute("cx", String(pt.x));
                b.dot.setAttribute("cy", String(pt.y));
              });
              raf = requestAnimationFrame(tick);
            };
            raf = requestAnimationFrame(tick);
          }
        };

        const update = (t) => {
          const t0 = clamp01(t);
          const active = Math.max(1, Math.round(lerp(1, 10, d3.easeCubicInOut(t0))));
          svg.select("text.branch-count").text(`${active} parallel attempts visible (slide to change)`);
        };

        observeSize(el, () => {
          build();
          update(state.t);
        });
        build();
        return { update };
      })();

      // ---- Chart 14: Turn-taking barcode (morphing segments) ----
      const barcodeChart = (() => {
        const el = $("#chart-barcode");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 74, r: 18, t: 28, b: 22 };
        let w = 0;
        let h = 0;
        let segments = null;

        const layout = (arr) => {
          const total = d3.sum(arr, (d) => d.w);
          let x = 0;
          return arr.map((d) => {
            const ww = d.w / total;
            const out = { ...d, x0: x, x1: x + ww };
            x += ww;
            return out;
          });
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const before = layout(DATA.barcode.before);
          const after = layout(DATA.barcode.after);
          const n = Math.max(before.length, after.length);
          segments = d3.range(n).map((i) => ({
            i,
            b: before[i] ?? { kind: "tool", x0: 1, x1: 1, w: 0 },
            a: after[i] ?? { kind: "tool", x0: 1, x1: 1, w: 0 },
          }));

          const trackW = w - pad.l - pad.r;
          const rowY0 = pad.t;
          const rowY1 = pad.t + 98;
          const rowH = 26;

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Gold = human turn, green = autonomous tool-call streak.");

          const rows = [
            { key: "Before", y: rowY0 },
            { key: "After", y: rowY1 },
          ];

          g.selectAll("text.rowlabel")
            .data(rows)
            .join("text")
            .attr("class", "rowlabel")
            .attr("x", pad.l - 10)
            .attr("y", (d) => d.y + rowH / 2)
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 12)
            .attr("font-weight", 700)
            .text((d) => d.key);

          g.selectAll("rect.track")
            .data(rows)
            .join("rect")
            .attr("class", "track")
            .attr("x", pad.l)
            .attr("y", (d) => d.y)
            .attr("width", trackW)
            .attr("height", rowH)
            .attr("rx", 12)
            .attr("fill", "rgba(0,0,0,0.18)")
            .attr("stroke", "rgba(233,237,255,0.14)");

          g.append("g")
            .attr("class", "segG")
            .selectAll("rect.seg")
            .data(segments, (d) => d.i)
            .join("rect")
            .attr("class", "seg")
            .attr("y", rowY0)
            .attr("height", rowH)
            .attr("rx", 6)
            .attr("x", pad.l + trackW)
            .attr("width", 0)
            .attr("fill", theme.a)
            .attr("fill-opacity", 0.78)
            .attr("stroke", "rgba(233,237,255,0.10)")
            .on("mousemove", (event) => {
              const bTurns = DATA.autonomy.metrics.find((m) => m.key === "Human turns")?.before ?? 6.2;
              const aTurns = DATA.autonomy.metrics.find((m) => m.key === "Human turns")?.after ?? 4.1;
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">Turn-taking</div>
                 <div class="t-row">Before human turns: <span class="kbdish">${fmt(bTurns)}</span></div>
                 <div class="t-row">After human turns: <span class="kbdish">${fmt(aTurns)}</span></div>
                 <div class="t-row">Green stripes = longer autonomous runs.</div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          g.append("rect")
            .attr("class", "scan")
            .attr("x", pad.l)
            .attr("y", rowY0 - 6)
            .attr("width", 10)
            .attr("height", rowH * 2 + 18)
            .attr("rx", 6)
            .attr("fill", "rgba(255,255,255,0.08)")
            .attr("stroke", "rgba(233,237,255,0.12)");

          if (!prefersReducedMotion) {
            const tick = () => {
              const t = (performance.now() / 1200) % 1;
              g.select("rect.scan").attr("x", pad.l + t * (trackW - 10));
              requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
          }

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).attr("class", "hint").text("Slide: fewer interruptions, longer bursts.");
        };

        const update = (t) => {
          if (!segments) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const trackW = w - pad.l - pad.r;
          const rowY0 = pad.t;
          const rowY1 = pad.t + 98;
          const rowH = 26;

          g.selectAll("rect.seg")
            .attr("y", () => lerp(rowY0, rowY1, ease))
            .attr("x", (d) => pad.l + lerp(d.b.x0, d.a.x0, ease) * trackW)
            .attr("width", (d) => Math.max(0, lerp(d.b.x1 - d.b.x0, d.a.x1 - d.a.x0, ease) * trackW))
            .attr("fill", (d) => ((ease < 0.5 ? d.b.kind : d.a.kind) === "human" ? theme.warn : theme.a))
            .attr("fill-opacity", (d) => 0.14 + 0.66 * lerp(d.b.w > 0 ? 1 : 0, d.a.w > 0 ? 1 : 0, ease));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 15: Learning curve shift (line morph) ----
      const curvesChart = (() => {
        const el = $("#chart-curves");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 44, r: 18, t: 18, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const data = DATA.curve;
          x = d3.scaleLinear().domain(d3.extent(data, (d) => d.day)).range([pad.l, w - pad.r]);
          y = d3.scaleLinear().domain([0, 100]).range([h - pad.b, pad.t]);

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(7).tickSizeOuter(0).tickFormat((d) => `day ${d}`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("g")
            .attr("transform", `translate(${pad.l},0)`)
            .call(d3.axisLeft(y).ticks(5).tickSizeOuter(0).tickFormat((d) => `${d}%`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Tighter feedback loops steepen the learning curve.");

          const line = d3
            .line()
            .x((d) => x(d.day))
            .y((d) => y(d.v))
            .curve(d3.curveMonotoneX);

          const bgBefore = data.map((d) => ({ day: d.day, v: d.before }));
          const bgAfter = data.map((d) => ({ day: d.day, v: d.after }));
          g.append("path").attr("class", "bg before").attr("d", line(bgBefore)).attr("fill", "none").attr("stroke", theme.b).attr("stroke-opacity", 0.24).attr("stroke-width", 4);
          g.append("path").attr("class", "bg after").attr("d", line(bgAfter)).attr("fill", "none").attr("stroke", theme.a).attr("stroke-opacity", 0.24).attr("stroke-width", 4);

          g.append("path")
            .attr("class", "focus")
            .attr("d", line(bgBefore))
            .attr("fill", "none")
            .attr("stroke", "rgba(233,237,255,0.92)")
            .attr("stroke-width", 3.2)
            .attr("stroke-linecap", "round");

          g.append("g")
            .selectAll("circle")
            .data(data)
            .join("circle")
            .attr("r", 4.4)
            .attr("fill", "rgba(233,237,255,0.85)")
            .attr("stroke", "rgba(0,0,0,0.4)")
            .attr("cx", (d) => x(d.day))
            .attr("cy", (d) => y(d.before))
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">Day ${d.day}</div>
                 <div class="t-row">Before: <span class="kbdish">${fmt0(d.before)}%</span></div>
                 <div class="t-row">After: <span class="kbdish">${fmt0(d.after)}%</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          g.append("text")
            .attr("x", (pad.l + (w - pad.r)) / 2)
            .attr("y", h - 10)
            .attr("text-anchor", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 11)
            .text("Time since starting an unfamiliar task →");

          el._curveLine = line;
        };

        const update = (t) => {
          if (!x || !y) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const data = DATA.curve;
          const line = el._curveLine;
          const mid = data.map((d) => ({ day: d.day, v: lerp(d.before, d.after, ease) }));
          g.select("path.focus").attr("d", line(mid));
          g.selectAll("circle")
            .attr("cy", (d) => y(lerp(d.before, d.after, ease)))
            .attr("r", () => 4.2 + Math.sin(performance.now() / 450) * 0.4);
          g.select("path.bg.before").attr("stroke-opacity", lerp(0.30, 0.12, ease));
          g.select("path.bg.after").attr("stroke-opacity", lerp(0.12, 0.30, ease));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 16: Quality-of-life flywheel (animated rotor) ----
      const flywheelChart = (() => {
        const el = $("#chart-flywheel");
        const svg = makeSvg(el);
        const g = svg.append("g");
        let w = 0;
        let h = 0;
        let raf = /** @type {number|null} */ (null);
        let angle = 0;

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const cx = w * 0.52;
          const cy = h * 0.54;
          const r0 = Math.min(w, h) * 0.16;
          const r1 = Math.min(w, h) * 0.40;

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Papercuts stop being perpetually deprioritized → the flywheel speeds up.");

          const rotor = g.append("g").attr("class", "rotor").attr("transform", `translate(${cx},${cy})`);
          rotor.append("circle").attr("r", r1 + 16).attr("fill", "none").attr("stroke", "rgba(233,237,255,0.10)").attr("stroke-dasharray", "5,12");
          rotor.append("circle").attr("r", r1).attr("fill", "rgba(0,0,0,0.14)").attr("stroke", "rgba(233,237,255,0.16)");
          rotor.append("circle").attr("r", r0).attr("fill", "rgba(6,10,18,0.65)").attr("stroke", "rgba(233,237,255,0.18)");

          const steps = [
            { label: "Fix papercuts", color: theme.danger },
            { label: "Less friction", color: theme.a },
            { label: "Faster output", color: theme.b },
            { label: "More time", color: theme.warn },
          ];

          const arc = d3.arc().innerRadius(r0 + 10).outerRadius(r1 - 12).cornerRadius(12).padAngle(0.02);
          const pie = d3.pie().sort(null).value(() => 1);
          const arcs = pie(steps);
          rotor
            .append("g")
            .selectAll("path")
            .data(arcs)
            .join("path")
            .attr("fill", (d) => d.data.color)
            .attr("fill-opacity", 0.52)
            .attr("stroke", "rgba(233,237,255,0.12)")
            .attr("d", arc);

          rotor
            .append("g")
            .selectAll("text")
            .data(arcs)
            .join("text")
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("fill", "rgba(8,10,16,0.88)")
            .attr("font-size", 12)
            .attr("font-weight", 800)
            .attr("transform", (d) => {
              const a = (d.startAngle + d.endAngle) / 2;
              return `translate(${Math.cos(a) * (r0 + (r1 - r0) * 0.62)},${Math.sin(a) * (r0 + (r1 - r0) * 0.62)})`;
            })
            .text((d) => d.data.label);

          const center = rotor.append("g").attr("class", "center");
          center.append("text").attr("class", "big").attr("text-anchor", "middle").attr("y", -8).attr("fill", theme.ink).attr("font-size", 28).attr("font-weight", 860).text("—");
          center.append("text").attr("class", "small").attr("text-anchor", "middle").attr("y", 18).attr("fill", theme.muted).attr("font-size", 12).text("friction min/day");

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).text("Slide to speed up the flywheel.");

          if (!prefersReducedMotion) {
            if (raf) cancelAnimationFrame(raf);
            const tick = () => {
              const tGlobal = d3.easeCubicInOut(clamp01(state.t));
              angle += lerp(0.001, 0.010, tGlobal);
              rotor.attr("transform", `translate(${cx},${cy}) rotate(${(angle * 180) / Math.PI})`);
              raf = requestAnimationFrame(tick);
            };
            raf = requestAnimationFrame(tick);
          }

          el._flywheel = { center };
        };

        const update = (t) => {
          const fw = el._flywheel;
          if (!fw) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const v = lerp(DATA.flywheel.before.frictionMin, DATA.flywheel.after.frictionMin, ease);
          fw.center.select("text.big").text(`${fmt0(v)}`);
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 17: Toil budget waffle (rearranging squares) ----
      const waffleChart = (() => {
        const el = $("#chart-waffle");
        const svg = makeSvg(el);
        const g = svg.append("g");
        let w = 0;
        let h = 0;
        let squares = null;

        const buildSquares = () => {
          const keys = DATA.waffle.keys;
          const colors = d3.scaleOrdinal(keys, [theme.b, theme.warn, "#a0c4ff", "#c8b6ff", theme.c, theme.danger, theme.a]);
          const fill = (obj) => {
            const out = [];
            let idx = 0;
            for (const k of keys) for (let i = 0; i < obj[k]; i++) out.push({ idx: idx++, k });
            while (out.length < 100) out.push({ idx: idx++, k: keys[keys.length - 1] });
            return out.slice(0, 100);
          };
          const before = fill(DATA.waffle.before);
          const after = fill(DATA.waffle.after);
          return d3.range(100).map((i) => ({ i, b: before[i].k, a: after[i].k, cb: colors(before[i].k), ca: colors(after[i].k) }));
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          const keys = DATA.waffle.keys;
          const colors = d3.scaleOrdinal(keys, [theme.b, theme.warn, "#a0c4ff", "#c8b6ff", theme.c, theme.danger, theme.a]);
          squares = buildSquares();

          const cols = 10;
          const cell = Math.min((w - 40) / cols, (h - 80) / 10);
          const origin = { x: (w - cols * cell) / 2, y: 42 };

          const countBy = (which) => {
            const m = Object.fromEntries(keys.map((k) => [k, 0]));
            squares.forEach((s) => (m[which === "b" ? s.b : s.a] += 1));
            return m;
          };
          const beforeCounts = countBy("b");
          const afterCounts = countBy("a");

          const place = (counts) => {
            const pos = new Map();
            let idx = 0;
            for (const k of keys) {
              for (let i = 0; i < counts[k]; i++) {
                const r = Math.floor(idx / cols);
                const c = idx % cols;
                pos.set(`${k}|${i}`, { x: origin.x + c * cell, y: origin.y + r * cell });
                idx++;
              }
            }
            return pos;
          };

          const beforePos = place(beforeCounts);
          const afterPos = place(afterCounts);

          const ranker = () => {
            const m = Object.fromEntries(keys.map((k) => [k, 0]));
            return (k) => `${k}|${m[k]++}`;
          };
          const keyB = ranker();
          const keyA = ranker();
          squares.forEach((s) => {
            s.kb = keyB(s.b);
            s.ka = keyA(s.a);
            s.pb = beforePos.get(s.kb);
            s.pa = afterPos.get(s.ka);
          });

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("100 squares = 100 engineer-hours/week. Hours drift into neglected work.");

          g.append("g")
            .selectAll("rect")
            .data(squares, (d) => d.i)
            .join("rect")
            .attr("x", (d) => d.pb.x)
            .attr("y", (d) => d.pb.y)
            .attr("width", cell - 3)
            .attr("height", cell - 3)
            .attr("rx", 6)
            .attr("fill", (d) => d.cb)
            .attr("fill-opacity", 0.78)
            .attr("stroke", "rgba(233,237,255,0.12)")
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">Hour block</div>
                 <div class="t-row">Before: <span class="kbdish">${d.b}</span></div>
                 <div class="t-row">After: <span class="kbdish">${d.a}</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          const legend = svg.append("g").attr("transform", `translate(${14},${h - 18})`);
          const items = ["Docs/tests", "Tools/dashboards", "Papercuts"];
          legend
            .selectAll("g.item")
            .data(items)
            .join((enter) => {
              const gg = enter.append("g").attr("class", "item");
              gg.append("rect").attr("width", 12).attr("height", 12).attr("rx", 4).attr("y", -10);
              gg.append("text").attr("x", 16).attr("y", -4).attr("dominant-baseline", "middle").attr("font-size", 11);
              return gg;
            })
            .attr("transform", (_, i) => `translate(${i * 170},0)`)
            .each(function (d) {
              const sel = d3.select(this);
              sel.select("rect").attr("fill", colors(d)).attr("fill-opacity", 0.85);
              sel.select("text").attr("fill", theme.muted).text(d);
            });
        };

        const update = (t) => {
          if (!squares) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          g.selectAll("rect")
            .attr("x", (d) => lerp(d.pb.x, d.pa.x, ease))
            .attr("y", (d) => lerp(d.pb.y, d.pa.y, ease))
            .attr("fill", (d) => d3.interpolateRgb(d.cb, d.ca)(ease))
            .attr("fill-opacity", lerp(0.78, 0.92, ease));
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Chart 18: Backlog age raincloud (density + dots) ----
      const raincloudChart = (() => {
        const el = $("#chart-raincloud");
        const svg = makeSvg(el);
        const g = svg.append("g");
        const pad = { l: 66, r: 18, t: 18, b: 34 };
        let w = 0;
        let h = 0;
        let x = null;
        let y = null;
        let dots = null;

        const kde = (values, xs) => {
          const kernel = (u) => (Math.abs(u) <= 1 ? 0.75 * (1 - u * u) : 0);
          const bw = 10;
          return xs.map((xx) => [xx, d3.mean(values, (v) => kernel((xx - v) / bw)) ?? 0]);
        };

        const render = () => {
          const rect = safeRect(el);
          if (!rect) return;
          w = Math.max(420, rect.width);
          h = rect.height;
          svg.attr("viewBox", `0 0 ${w} ${h}`);
          g.selectAll("*").remove();

          x = d3.scaleLinear().domain([0, 120]).range([pad.l, w - pad.r]);
          y = d3.scaleBand().domain(DATA.ageData.categories).range([pad.t + 10, h - pad.b]).padding(0.30);

          g.append("g")
            .attr("transform", `translate(0,${h - pad.b})`)
            .call(d3.axisBottom(x).ticks(6).tickSizeOuter(0).tickFormat((d) => `${d}d`))
            .call((sel) => sel.selectAll("text").attr("fill", theme.muted))
            .call((sel) => sel.selectAll("path,line").attr("stroke", theme.grid));

          g.selectAll("text.row")
            .data(DATA.ageData.categories)
            .join("text")
            .attr("class", "row")
            .attr("x", pad.l - 10)
            .attr("y", (d) => (y(d) ?? 0) + y.bandwidth() / 2)
            .attr("text-anchor", "end")
            .attr("dominant-baseline", "middle")
            .attr("fill", theme.muted)
            .attr("font-size", 12)
            .attr("font-weight", 700)
            .text((d) => d);

          g.append("text").attr("x", 14).attr("y", 18).attr("fill", theme.muted).attr("font-size", 11).text("Rainclouds shift left as long-stale neglected items finally get done.");

          const xs = d3.range(0, 121, 3);
          const color = d3.scaleOrdinal(DATA.ageData.categories, ["#c8b6ff", theme.c, theme.danger]);
          const densityG = g.append("g").attr("class", "density");
          const dotsG = g.append("g").attr("class", "dots");

          const seeded = d3.randomLcg(0.61);
          const jitter = d3.randomNormal.source(seeded)(0, 5);

          const byCat = (arr) => d3.group(arr, (d) => d.c);
          const B = byCat(DATA.ageData.before);
          const A = byCat(DATA.ageData.after);
          dots = [];
          for (const c of DATA.ageData.categories) {
            const b = B.get(c) ?? [];
            const a = A.get(c) ?? [];
            const n = Math.min(b.length, a.length);
            for (let i = 0; i < n; i++) dots.push({ c, i, bd: b[i].days, ad: a[i].days, jy: jitter() });
          }

          const drawDensity = (tt) => {
            const ease = d3.easeCubicInOut(clamp01(tt));
            const paths = DATA.ageData.categories.map((c) => {
              const vs = dots.filter((d) => d.c === c).map((d) => lerp(d.bd, d.ad, ease));
              const den = kde(vs, xs);
              const maxV = d3.max(den, (d) => d[1]) ?? 1;
              const amp = (y.bandwidth() * 0.42) / maxV;
              const base = (y(c) ?? 0) + y.bandwidth() / 2;
              const area = d3
                .area()
                .x((d) => x(d[0]))
                .y0(base)
                .y1((d) => base - d[1] * amp)
                .curve(d3.curveBasis);
              return { c, d: area(den) };
            });

            densityG
              .selectAll("path")
              .data(paths, (d) => d.c)
              .join("path")
              .attr("d", (d) => d.d)
              .attr("fill", (d) => color(d.c))
              .attr("fill-opacity", lerp(0.14, 0.30, ease))
              .attr("stroke", "rgba(233,237,255,0.12)");
          };

          dotsG
            .selectAll("circle")
            .data(dots, (d) => `${d.c}|${d.i}`)
            .join("circle")
            .attr("r", 2.8)
            .attr("fill", (d) => color(d.c))
            .attr("fill-opacity", 0.62)
            .attr("stroke", "rgba(233,237,255,0.10)")
            .on("mousemove", (event, d) => {
              const pos = pointer(event, el);
              tooltip.show(
                `<div class="t-title">${d.c}</div>
                 <div class="t-row">Before age: <span class="kbdish">${fmt0(d.bd)}d</span></div>
                 <div class="t-row">After age: <span class="kbdish">${fmt0(d.ad)}d</span></div>`,
                pos.x,
                pos.y
              );
            })
            .on("mouseleave", () => tooltip.hide());

          svg.append("text").attr("x", 14).attr("y", h - 12).attr("fill", theme.muted).attr("font-size", 11).text("X-axis = age when completed. Leftward = less staleness.");
          el._drawDensity = drawDensity;
          drawDensity(0);
        };

        const update = (t) => {
          if (!dots || !x || !y) return;
          const t0 = clamp01(t);
          const ease = d3.easeCubicInOut(t0);
          const baseY = (c) => (y(c) ?? 0) + y.bandwidth() / 2;
          g.selectAll("g.dots circle")
            .attr("cx", (d) => x(lerp(d.bd, d.ad, ease)))
            .attr("cy", (d) => baseY(d.c) + d.jy * 0.55)
            .attr("fill-opacity", lerp(0.48, 0.78, ease));
          el._drawDensity?.(t0);
        };

        observeSize(el, () => {
          render();
          update(state.t);
        });
        render();
        return { update };
      })();

      // ---- Global state + animation wiring ----
      const charts = [
        sankeyChart,
        bloomChart,
        scatterChart,
        matrixChart,
        firefliesChart,
        compassChart,
        loopChart,
        autonomyChart,
        learningChart,
        horsesChart,
        barcodeChart,
        curvesChart,
        icebergChart,
        burndownChart,
        portfolioChart,
        flywheelChart,
        waffleChart,
        raincloudChart,
      ];

      const applyT = (t) => {
        state.t = clamp01(t);
        $("#global-t").value = String(state.t);
        for (const c of charts) c.update(state.t);
      };

      const play = () => {
        if (state.playing) return;
        state.playing = true;
        $("#btn-play").textContent = "Pause";
        const start = performance.now();
        const from = state.t;
        const to = from < 0.98 ? 1 : 0;
        const dur = prefersReducedMotion ? 0 : 1400;

        const tick = (now) => {
          const p = dur === 0 ? 1 : clamp01((now - start) / dur);
          applyT(lerp(from, to, d3.easeCubicInOut(p)));
          if (p >= 1) {
            state.playing = false;
            $("#btn-play").textContent = "Play";
            state.raf = null;
            return;
          }
          state.raf = requestAnimationFrame(tick);
        };
        state.raf = requestAnimationFrame(tick);
      };

      const pause = () => {
        state.playing = false;
        $("#btn-play").textContent = "Play";
        if (state.raf) cancelAnimationFrame(state.raf);
        state.raf = null;
      };

      $("#global-t").addEventListener("input", (e) => {
        pause();
        applyT(Number(e.target.value));
      });

      $("#btn-play").addEventListener("click", () => (state.playing ? pause() : play()));
      $("#btn-scrub").addEventListener("click", () => {
        pause();
        applyT(0);
      });

      // Initial paint
      applyT(0);
    </script>
  </body>
</html>
